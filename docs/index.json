{
  "api/FastEndpoints.BaseEndpoint.html": {
    "href": "api/FastEndpoints.BaseEndpoint.html",
    "title": "Class BaseEndpoint | FastEndpoints",
    "keywords": "Class BaseEndpoint Inheritance System.Object BaseEndpoint Endpoint<TRequest, TResponse> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class BaseEndpoint : IEndpoint Fields _httpContext Declaration protected HttpContext _httpContext Field Value Type Description Microsoft.AspNetCore.Http.HttpContext Properties HttpContext the http context of the current request Declaration public HttpContext HttpContext { get; } Property Value Type Description Microsoft.AspNetCore.Http.HttpContext ValidationFailures the list of validation failures for the current request dto Declaration public List<ValidationFailure> ValidationFailures { get; } Property Value Type Description List < ValidationFailure > Methods Configure() use this method to configure how the endpoint should be listening to incoming requests. HINT: it is only called once during endpoint auto registration during app startup. Declaration public abstract void Configure()"
  },
  "api/FastEndpoints.Config.html": {
    "href": "api/FastEndpoints.Config.html",
    "title": "Class Config | FastEndpoints",
    "keywords": "Class Config global configuration settings for FastEndpoints Inheritance System.Object Config Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class Config Properties EndpointRegistrationFilter a function to filter out endpoints from auto registration. return 'false' from the function if you want to exclude an endpoint from registration. return 'true' to include. this function will executed for each endpoint that has been discovered during startup. Declaration public Func<DiscoveredEndpoint, bool> EndpointRegistrationFilter { set; } Property Value Type Description Func < DiscoveredEndpoint , System.Boolean > ErrorResponseBuilder a function for transforming validation errors to an error response dto. set it to any func that returns an object that can be serialized to json. this function will be run everytime an error response needs to be sent to the client. Declaration public Func<IEnumerable<ValidationFailure>, object> ErrorResponseBuilder { set; } Property Value Type Description Func < IEnumerable < ValidationFailure >, System.Object > RequestDeserializer a function for deserializing the incoming http request body. this function will be executed for each request received if it has json request body. the parameters of the func are as follows: HttpRequest: the incoming request Type: the type of the request dto which the request body will be deserialized into CancellationToken: a cancellation token Declaration public Func<HttpRequest, Type, CancellationToken, ValueTask<object>> RequestDeserializer { set; } Property Value Type Description Func < Microsoft.AspNetCore.Http.HttpRequest , Type , CancellationToken , ValueTask < System.Object >> ResponseSerializer a function for writing serialized response dtos to the response body. this function will be executed whenever a json response is being sent to the client. you should set the content-type and write directly to the http response body stream in this function. the parameters of the func are as follows: HttpResponse: the http response object object: the response dto to be serialized string: the response content-type CancellationToken: a cancellation token config.ResponseSerializer = (rsp, dto, cType, ct) => { rsp.ContentType = cType; return rsp.WriteAsync(Newtonsoft.Json.JsonConvert.SerializeObject(dto), ct); }; Declaration public Func<HttpResponse, object, string, CancellationToken, Task> ResponseSerializer { set; } Property Value Type Description Func < Microsoft.AspNetCore.Http.HttpResponse , System.Object , System.String , CancellationToken , Task > RoutingOptions routing options for all endpoints Declaration public Action<RoutingOptions> RoutingOptions { set; } Property Value Type Description Action < RoutingOptions > SerializerOptions settings for configuring the json serializer Declaration public Action<JsonSerializerOptions> SerializerOptions { set; } Property Value Type Description Action < System.Text.Json.JsonSerializerOptions > VersioningOptions options for enabling endpoint versioning support Declaration public Action<VersioningOptions> VersioningOptions { set; } Property Value Type Description Action < VersioningOptions >"
  },
  "api/FastEndpoints.DiscoveredEndpoint.html": {
    "href": "api/FastEndpoints.DiscoveredEndpoint.html",
    "title": "Class DiscoveredEndpoint | FastEndpoints",
    "keywords": "Class DiscoveredEndpoint represents an endpoint that has been discovered during startup Inheritance System.Object DiscoveredEndpoint Implements System.IEquatable < DiscoveredEndpoint > Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class DiscoveredEndpoint : IEquatable<DiscoveredEndpoint> Constructors DiscoveredEndpoint(Type, IEnumerable<String>, IEnumerable<String>, Nullable<IEnumerable<String>>, Boolean, Nullable<IEnumerable<String>>, Nullable<IEnumerable<String>>, Nullable<IEnumerable<String>>, Boolean, Nullable<IEnumerable<String>>, Boolean, Nullable<IEnumerable<String>>, String) represents an endpoint that has been discovered during startup Declaration public DiscoveredEndpoint(Type EndpointType, IEnumerable<string> Routes, IEnumerable<string> Verbs, IEnumerable<string>? AnonymousVerbs, bool ThrowIfValidationFails, IEnumerable<string>? Policies, IEnumerable<string>? Roles, IEnumerable<string>? Permissions, bool AllowAnyPermission, IEnumerable<string>? Claims, bool AllowAnyClaim, IEnumerable<string>? Tags, string Version) Parameters Type Name Description Type EndpointType the type of the discovered endpoint class IEnumerable < System.String > Routes the routes the endpoint will match IEnumerable < System.String > Verbs the http verbs the endpoint will be listening for System.Nullable < IEnumerable < System.String >> AnonymousVerbs the verbs which will be allowed anonymous access to System.Boolean ThrowIfValidationFails whether automatic validation failure will be sent System.Nullable < IEnumerable < System.String >> Policies the security policies for the endpoint System.Nullable < IEnumerable < System.String >> Roles the roles which will be allowed access to System.Nullable < IEnumerable < System.String >> Permissions the permissions which will allow access System.Boolean AllowAnyPermission whether any or all permissions will be required System.Nullable < IEnumerable < System.String >> Claims the user claim types which will allow access System.Boolean AllowAnyClaim whether any or all claim types will be required System.Nullable < IEnumerable < System.String >> Tags the tags associated with the endpoint System.String Version the version of the endpoint if specified Properties AllowAnyClaim Declaration public bool AllowAnyClaim { get; set; } Property Value Type Description System.Boolean AllowAnyPermission Declaration public bool AllowAnyPermission { get; set; } Property Value Type Description System.Boolean AnonymousVerbs Declaration public IEnumerable<string>? AnonymousVerbs { get; set; } Property Value Type Description System.Nullable < IEnumerable < System.String >> Claims Declaration public IEnumerable<string>? Claims { get; set; } Property Value Type Description System.Nullable < IEnumerable < System.String >> EndpointType Declaration public Type EndpointType { get; set; } Property Value Type Description Type Permissions Declaration public IEnumerable<string>? Permissions { get; set; } Property Value Type Description System.Nullable < IEnumerable < System.String >> Policies Declaration public IEnumerable<string>? Policies { get; set; } Property Value Type Description System.Nullable < IEnumerable < System.String >> Roles Declaration public IEnumerable<string>? Roles { get; set; } Property Value Type Description System.Nullable < IEnumerable < System.String >> Routes Declaration public IEnumerable<string> Routes { get; set; } Property Value Type Description IEnumerable < System.String > Tags Declaration public IEnumerable<string>? Tags { get; set; } Property Value Type Description System.Nullable < IEnumerable < System.String >> ThrowIfValidationFails Declaration public bool ThrowIfValidationFails { get; set; } Property Value Type Description System.Boolean Verbs Declaration public IEnumerable<string> Verbs { get; set; } Property Value Type Description IEnumerable < System.String > Version Declaration public string Version { get; set; } Property Value Type Description System.String Implements System.IEquatable<T>"
  },
  "api/FastEndpoints.EmptyRequest.html": {
    "href": "api/FastEndpoints.EmptyRequest.html",
    "title": "Class EmptyRequest | FastEndpoints",
    "keywords": "Class EmptyRequest a request dto that doesn't have any properties Inheritance System.Object EmptyRequest Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public sealed class EmptyRequest"
  },
  "api/FastEndpoints.EmptyResponse.html": {
    "href": "api/FastEndpoints.EmptyResponse.html",
    "title": "Class EmptyResponse | FastEndpoints",
    "keywords": "Class EmptyResponse a response dto that doesn't have any properties Inheritance System.Object EmptyResponse Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public sealed class EmptyResponse"
  },
  "api/FastEndpoints.Endpoint-1.html": {
    "href": "api/FastEndpoints.Endpoint-1.html",
    "title": "Class Endpoint<TRequest> | FastEndpoints",
    "keywords": "Class Endpoint<TRequest> use this base class for defining endpoints that only use a request dto and don't use a response dto. Inheritance System.Object BaseEndpoint Endpoint <TRequest, System.Object > Endpoint<TRequest> EndpointWithoutRequest Inherited Members Endpoint<TRequest, Object>.HandleAsync(TRequest, CancellationToken) Endpoint<TRequest, Object>.TryResolve<TService>() Endpoint<TRequest, Object>.TryResolve(Type) Endpoint<TRequest, Object>.Resolve<TService>() Endpoint<TRequest, Object>.Resolve(Type) Endpoint<TRequest, Object>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<TRequest, Object>.OnBeforeValidate(TRequest) Endpoint<TRequest, Object>.OnBeforeValidateAsync(TRequest) Endpoint<TRequest, Object>.OnAfterValidate(TRequest) Endpoint<TRequest, Object>.OnAfterValidateAsync(TRequest) Endpoint<TRequest, Object>.OnBeforeHandle(TRequest) Endpoint<TRequest, Object>.OnBeforeHandleAsync(TRequest) Endpoint<TRequest, Object>.OnAfterHandle(TRequest, Object) Endpoint<TRequest, Object>.OnAfterHandleAsync(TRequest, Object) Endpoint<TRequest, Object>.ValidationFailed Endpoint<TRequest, Object>.User Endpoint<TRequest, Object>.Response Endpoint<TRequest, Object>.Config Endpoint<TRequest, Object>.Env Endpoint<TRequest, Object>.Logger Endpoint<TRequest, Object>.BaseURL Endpoint<TRequest, Object>.HttpMethod Endpoint<TRequest, Object>.Form Endpoint<TRequest, Object>.Files Endpoint<TRequest, Object>.SendAsync(Object, Int32, CancellationToken) Endpoint<TRequest, Object>.SendCreatedAtAsync<TEndpoint>(Object, Object, CancellationToken) Endpoint<TRequest, Object>.SendCreatedAtAsync(String, Object, Object, CancellationToken) Endpoint<TRequest, Object>.SendStringAsync(String, Int32, CancellationToken) Endpoint<TRequest, Object>.SendOkAsync(CancellationToken) Endpoint<TRequest, Object>.SendErrorsAsync(CancellationToken) Endpoint<TRequest, Object>.SendNoContentAsync(CancellationToken) Endpoint<TRequest, Object>.SendNotFoundAsync(CancellationToken) Endpoint<TRequest, Object>.SendUnauthorizedAsync(CancellationToken) Endpoint<TRequest, Object>.SendForbiddenAsync(CancellationToken) Endpoint<TRequest, Object>.SendBytesAsync(Byte[], String, String, CancellationToken) Endpoint<TRequest, Object>.SendFileAsync(FileInfo, String, CancellationToken) Endpoint<TRequest, Object>.SendStreamAsync(Stream, String, Nullable<Int64>, String, CancellationToken) Endpoint<TRequest, Object>.SendEmptyJsonObject(CancellationToken) Endpoint<TRequest, Object>.Get(String[]) Endpoint<TRequest, Object>.Post(String[]) Endpoint<TRequest, Object>.Put(String[]) Endpoint<TRequest, Object>.Patch(String[]) Endpoint<TRequest, Object>.Delete(String[]) Endpoint<TRequest, Object>.Routes(String[]) Endpoint<TRequest, Object>.Verbs(Http[]) Endpoint<TRequest, Object>.DontThrowIfValidationFails() Endpoint<TRequest, Object>.AllowAnonymous(Http[]) Endpoint<TRequest, Object>.AllowFileUploads() Endpoint<TRequest, Object>.AllowFormData() Endpoint<TRequest, Object>.Policies(String[]) Endpoint<TRequest, Object>.Roles(String[]) Endpoint<TRequest, Object>.Permissions(String[]) Endpoint<TRequest, Object>.PermissionsAll(String[]) Endpoint<TRequest, Object>.Claims(String[]) Endpoint<TRequest, Object>.ClaimsAll(String[]) Endpoint<TRequest, Object>.PreProcessors(IPreProcessor<TRequest>[]) Endpoint<TRequest, Object>.PostProcessors(IPostProcessor<TRequest, Object>[]) Endpoint<TRequest, Object>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<TRequest, Object>.Options(Action<RouteHandlerBuilder>) Endpoint<TRequest, Object>.Describe(Action<RouteHandlerBuilder>) Endpoint<TRequest, Object>.Tags(String[]) Endpoint<TRequest, Object>.Version(String) Endpoint<TRequest, Object>.AddError(String) Endpoint<TRequest, Object>.AddError(Expression<Func<TRequest, Object>>, String) Endpoint<TRequest, Object>.ThrowIfAnyErrors() Endpoint<TRequest, Object>.ThrowError(String) Endpoint<TRequest, Object>.ThrowError(Expression<Func<TRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.HttpContext BaseEndpoint.Configure() BaseEndpoint.ValidationFailures System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Endpoint<TRequest> : Endpoint<TRequest, object>, IEndpoint, IServiceResolver where TRequest : class, new() Type Parameters Name Description TRequest the type of the request dto"
  },
  "api/FastEndpoints.Endpoint-2.html": {
    "href": "api/FastEndpoints.Endpoint-2.html",
    "title": "Class Endpoint<TRequest, TResponse> | FastEndpoints",
    "keywords": "Class Endpoint<TRequest, TResponse> use this base class for defining endpoints that use both request and response dtos. Inheritance System.Object BaseEndpoint Endpoint<TRequest, TResponse> Endpoint<TRequest> Endpoint<TRequest, TResponse, TMapper> EndpointWithMapping<TRequest, TResponse, TEntity> EndpointWithoutRequest<TResponse> Inherited Members BaseEndpoint._httpContext BaseEndpoint.HttpContext BaseEndpoint.Configure() BaseEndpoint.ValidationFailures System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Endpoint<TRequest, TResponse> : BaseEndpoint, IEndpoint, IServiceResolver where TRequest : class, new() where TResponse : new() Type Parameters Name Description TRequest the type of the request dto TResponse the type of the response dto Properties BaseURL the base url of the current request Declaration protected string BaseURL { get; } Property Value Type Description System.String Config gives access to the configuration Declaration protected IConfiguration Config { get; } Property Value Type Description Microsoft.Extensions.Configuration.IConfiguration Env gives access to the hosting environment Declaration protected IWebHostEnvironment Env { get; } Property Value Type Description Microsoft.AspNetCore.Hosting.IWebHostEnvironment Files the files sent with the request. only populated when content-type is 'multipart/form-data' Declaration protected IFormFileCollection Files { get; } Property Value Type Description Microsoft.AspNetCore.Http.IFormFileCollection Form the form sent with the request. only populated if content-type is 'application/x-www-form-urlencoded' or 'multipart/form-data' Declaration protected IFormCollection Form { get; } Property Value Type Description Microsoft.AspNetCore.Http.IFormCollection HttpMethod the http method of the current request Declaration protected Http HttpMethod { get; } Property Value Type Description Http Logger the logger for the current endpoint type Declaration protected ILogger Logger { get; } Property Value Type Description Microsoft.Extensions.Logging.ILogger Response the response that is sent to the client. Declaration protected TResponse Response { get; set; } Property Value Type Description TResponse User the current user principal Declaration protected ClaimsPrincipal User { get; } Property Value Type Description System.Security.Claims.ClaimsPrincipal ValidationFailed indicates if there are any validation failures for the current request Declaration protected bool ValidationFailed { get; } Property Value Type Description System.Boolean Methods AddError(Expression<Func<TRequest, Object>>, String) adds an error message for the specified property of the request dto Declaration protected void AddError(Expression<Func<TRequest, object>> property, string errorMessage) Parameters Type Name Description System.Linq.Expressions.Expression < Func <TRequest, System.Object >> property the property to add teh error message for System.String errorMessage the error message AddError(String) adds a \"GeneralError\" to the current list of validation failures Declaration protected void AddError(string message) Parameters Type Name Description System.String message the error message AllowAnonymous(Http[]) allow unauthenticated requests to this endpoint. optionally specify a set of verbs to allow unauthenticated access with. i.e. if the endpoint is listening to POST, PUT & PATCH and you specify AllowAnonymous(Http.POST), then only PUT & PATCH will require authentication. Declaration protected void AllowAnonymous(params Http[] verbs) Parameters Type Name Description Http [] verbs AllowFileUploads() enable file uploads with multipart/form-data content type Declaration protected void AllowFileUploads() AllowFormData() enable multipart/form-data submissions Declaration protected void AllowFormData() Claims(String[]) allows access if the claims principal has ANY of the given claim types Declaration protected void Claims(params string[] claimTypes) Parameters Type Name Description System.String [] claimTypes the claim types ClaimsAll(String[]) allows access if the claims principal has ALL of the given claim types Declaration protected void ClaimsAll(params string[] claimTypes) Parameters Type Name Description System.String [] claimTypes the claim types Delete(String[]) specify to listen for DELETE requests on one or more routes. Declaration protected void Delete(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns Describe(Action<RouteHandlerBuilder>) describe openapi metadata for this endpoint. this method clears the default Accepts/Produces metadata. b => b.Accepts<Request>(\"text/plain\") Declaration protected void Describe(Action<RouteHandlerBuilder> builder) Parameters Type Name Description Action < Microsoft.AspNetCore.Builder.RouteHandlerBuilder > builder the route handler builder for this endpoint DontThrowIfValidationFails() disable auto validation failure responses (400 bad request with error details) for this endpoint Declaration protected void DontThrowIfValidationFails() Get(String[]) specify to listen for GET requests on one or more routes. Declaration protected void Get(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns HandleAsync(TRequest, CancellationToken) the handler method for the endpoint. this method is called for each request received. Declaration public abstract Task HandleAsync(TRequest req, CancellationToken ct) Parameters Type Name Description TRequest req the request dto CancellationToken ct a cancellation token Returns Type Description Task OnAfterHandle(TRequest, TResponse) override this method if you'd like to do something after the handler is executed. Declaration public virtual void OnAfterHandle(TRequest req, TResponse res) Parameters Type Name Description TRequest req the request dto TResponse res the response dto that was sent to the client OnAfterHandleAsync(TRequest, TResponse) override this method if you'd like to do something after the handler is executed. Declaration public virtual Task OnAfterHandleAsync(TRequest req, TResponse res) Parameters Type Name Description TRequest req the request dto TResponse res the response dto that was sent to the client Returns Type Description Task OnAfterValidate(TRequest) override this method if you'd like to do something to the request dto after it gets validated. Declaration public virtual void OnAfterValidate(TRequest req) Parameters Type Name Description TRequest req the request dto OnAfterValidateAsync(TRequest) override this method if you'd like to do something to the request dto after it gets validated. Declaration public virtual Task OnAfterValidateAsync(TRequest req) Parameters Type Name Description TRequest req the request dto Returns Type Description Task OnBeforeHandle(TRequest) override this method if you'd like to do something to the request dto before the handler is executed. Declaration public virtual void OnBeforeHandle(TRequest req) Parameters Type Name Description TRequest req the request dto OnBeforeHandleAsync(TRequest) override this method if you'd like to do something to the request dto before the handler is executed. Declaration public virtual Task OnBeforeHandleAsync(TRequest req) Parameters Type Name Description TRequest req the request dto Returns Type Description Task OnBeforeValidate(TRequest) override this method if you'd like to do something to the request dto before it gets validated. Declaration public virtual void OnBeforeValidate(TRequest req) Parameters Type Name Description TRequest req the request dto OnBeforeValidateAsync(TRequest) override this method if you'd like to do something to the request dto before it gets validated. Declaration public virtual Task OnBeforeValidateAsync(TRequest req) Parameters Type Name Description TRequest req the request dto Returns Type Description Task Options(Action<RouteHandlerBuilder>) set endpoint configurations options using an endpoint builder action /// Declaration protected void Options(Action<RouteHandlerBuilder> builder) Parameters Type Name Description Action < Microsoft.AspNetCore.Builder.RouteHandlerBuilder > builder the builder for this endpoint Patch(String[]) specify to listen for PATCH requests on one or more routes. Declaration protected void Patch(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns Permissions(String[]) allows access if the claims principal has ANY of the given permissions Declaration protected void Permissions(params string[] permissions) Parameters Type Name Description System.String [] permissions the permissions PermissionsAll(String[]) allows access if the claims principal has ALL of the given permissions Declaration protected void PermissionsAll(params string[] permissions) Parameters Type Name Description System.String [] permissions the permissions Policies(String[]) specify one or more authorization policy names you have added to the middleware pipeline during app startup/ service configuration that should be applied to this endpoint. Declaration protected void Policies(params string[] policyNames) Parameters Type Name Description System.String [] policyNames one or more policy names (must have been added to the pipeline on startup) Post(String[]) specify to listen for POST requests on one or more routes. Declaration protected void Post(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns PostProcessors(IPostProcessor<TRequest, TResponse>[]) configure a collection of post-processors to be executed after the main handler function is done. processors are executed in the order they are defined here. Declaration protected void PostProcessors(params IPostProcessor<TRequest, TResponse>[] postProcessors) Parameters Type Name Description IPostProcessor <TRequest, TResponse>[] postProcessors the post processors to be executed PreProcessors(IPreProcessor<TRequest>[]) configure a collection of pre-processors to be executed before the main handler function is called. processors are executed in the order they are defined here. Declaration protected void PreProcessors(params IPreProcessor<TRequest>[] preProcessors) Parameters Type Name Description IPreProcessor <TRequest>[] preProcessors the pre processors to be executed PublishAsync<TEvent>(TEvent, Mode, CancellationToken) publish the given model/dto to all the subscribers of the event notification Declaration public Task PublishAsync<TEvent>(TEvent eventModel, Mode waitMode = Mode.WaitForAll, CancellationToken cancellation = null) where TEvent : class Parameters Type Name Description TEvent eventModel the notification event model/dto to publish Mode waitMode specify whether to wait for none, any or all of the subscribers to complete their work CancellationToken cancellation an optional cancellation token Returns Type Description Task a Task that matches the wait mode specified. Mode.WaitForNone returns an already completed Task (fire and forget). Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work. Mode.WaitForAll return a Task that will complete only when all of the subscribers complete their work. Type Parameters Name Description TEvent Put(String[]) specify to listen for PUT requests on one or more routes. Declaration protected void Put(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns Resolve(Type) resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public object Resolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object Resolve<TService>() resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public TService Resolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) specify response caching settings for this endpoint Declaration protected void ResponseCache(int durationSeconds, ResponseCacheLocation location = ResponseCacheLocation.Any, bool noStore = false, string varyByHeader = null, string[] varyByQueryKeys = null) Parameters Type Name Description System.Int32 durationSeconds the duration in seconds for which the response is cached Microsoft.AspNetCore.Mvc.ResponseCacheLocation location the location where the data from a particular URL must be cached System.Boolean noStore specify whether the data should be stored or not System.String varyByHeader the value for the Vary response header System.String [] varyByQueryKeys the query keys to vary by Roles(String[]) allows access if the claims principal has ANY of the given roles Declaration protected void Roles(params string[] rolesNames) Parameters Type Name Description System.String [] rolesNames one or more roles that has access Routes(String[]) specify one or more route patterns this endpoint should be listening for Declaration protected void Routes(params string[] patterns) Parameters Type Name Description System.String [] patterns SendAsync(TResponse, Int32, CancellationToken) send the supplied response dto serialized as json to the client. Declaration protected Task SendAsync(TResponse response, int statusCode = 200, CancellationToken cancellation = null) Parameters Type Name Description TResponse response the object to serialize to json System.Int32 statusCode optional custom http status code CancellationToken cancellation optional cancellation token Returns Type Description Task SendBytesAsync(Byte[], String, String, CancellationToken) send a byte array to the client Declaration protected async Task SendBytesAsync(byte[] bytes, string fileName = null, string contentType = \"application/octet-stream\", CancellationToken cancellation = null) Parameters Type Name Description System.Byte [] bytes the bytes to send System.String fileName System.String contentType optional content type to set on the http response CancellationToken cancellation optional cancellation token Returns Type Description Task SendCreatedAtAsync(String, Object, TResponse, CancellationToken) send a 201 created response with a location header containing where the resource can be retrieved from. WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi route endpoint. Declaration protected Task SendCreatedAtAsync(string endpointName, object routeValues, TResponse responseBody, CancellationToken cancellation = null) Parameters Type Name Description System.String endpointName the name of the endpoint to use for link generation (openapi route id) System.Object routeValues a route values object with key/value pairs of route information TResponse responseBody the content to be serialized in the response body CancellationToken cancellation cancellation token Returns Type Description Task SendCreatedAtAsync<TEndpoint>(Object, TResponse, CancellationToken) send a 201 created response with a location header containing where the resource can be retrieved from. WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi route endpoint. Declaration protected Task SendCreatedAtAsync<TEndpoint>(object routeValues, TResponse responseBody, CancellationToken cancellation = null) where TEndpoint : IEndpoint Parameters Type Name Description System.Object routeValues a route values object with key/value pairs of route information TResponse responseBody the content to be serialized in the response body CancellationToken cancellation cancellation token Returns Type Description Task Type Parameters Name Description TEndpoint the type of the endpoint where the resource can be retrieved from SendEmptyJsonObject(CancellationToken) send an empty json object in the body Declaration protected Task SendEmptyJsonObject(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token Returns Type Description Task SendErrorsAsync(CancellationToken) send a 400 bad request with error details of the current validation failures Declaration protected Task SendErrorsAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation Returns Type Description Task SendFileAsync(FileInfo, String, CancellationToken) send a file to the client Declaration protected Task SendFileAsync(FileInfo fileInfo, string contentType = \"application/octet-stream\", CancellationToken cancellation = null) Parameters Type Name Description FileInfo fileInfo System.String contentType optional content type to set on the http response CancellationToken cancellation optional cancellation token Returns Type Description Task SendForbiddenAsync(CancellationToken) send a 403 unauthorized response Declaration protected Task SendForbiddenAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token Returns Type Description Task SendNoContentAsync(CancellationToken) send a 204 no content response Declaration protected Task SendNoContentAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token Returns Type Description Task SendNotFoundAsync(CancellationToken) send a 404 not found response Declaration protected Task SendNotFoundAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token Returns Type Description Task SendOkAsync(CancellationToken) send an http 200 ok response without any body Declaration protected Task SendOkAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token Returns Type Description Task SendStreamAsync(Stream, String, Nullable<Int64>, String, CancellationToken) send the contents of a stream to the client Declaration protected Task SendStreamAsync(Stream stream, string fileName = null, long? fileLengthBytes = null, string contentType = \"application/octet-stream\", CancellationToken cancellation = null) Parameters Type Name Description Stream stream the stream to read the data from System.String fileName and optional file name to set in the content-disposition header System.Nullable < System.Int64 > fileLengthBytes optional total size of the file/stream System.String contentType optional content type to set on the http response CancellationToken cancellation optional cancellation token Returns Type Description Task SendStringAsync(String, Int32, CancellationToken) send the supplied string content to the client. Declaration protected Task SendStringAsync(string content, int statusCode = 200, CancellationToken cancellation = null) Parameters Type Name Description System.String content the string to write to the response body System.Int32 statusCode optional custom http status code CancellationToken cancellation optional cancellation token Returns Type Description Task SendUnauthorizedAsync(CancellationToken) send a 401 unauthorized response Declaration protected Task SendUnauthorizedAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token Returns Type Description Task Tags(String[]) specify one or more string tags for this endpoint so they can be used in the exclusion filter during registration. Declaration protected void Tags(params string[] endpointTags) Parameters Type Name Description System.String [] endpointTags the tag values to associate with this endpoint ThrowError(Expression<Func<TRequest, Object>>, String) adds an error message for the specified property of the request dto and sends back a 400 bad request with error details immediately interrupting handler execution flow. no execution will continue past this call. Declaration protected void ThrowError(Expression<Func<TRequest, object>> property, string errorMessage) Parameters Type Name Description System.Linq.Expressions.Expression < Func <TRequest, System.Object >> property System.String errorMessage ThrowError(String) add a \"GeneralError\" to the validation failure list and send back a 400 bad request with error details immediately interrupting handler execution flow. if there are any vallidation failures, no execution will continue past this call. Declaration protected void ThrowError(string message) Parameters Type Name Description System.String message the error message ThrowIfAnyErrors() interrupt the flow of handler execution and send a 400 bad request with error details if there are any validation failures in the current request. if there are no validation failures, execution will continue past this call. Declaration protected void ThrowIfAnyErrors() TryResolve(Type) try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public object TryResolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object TryResolve<TService>() try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public TService TryResolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve Verbs(Http[]) specify one or more http method verbs this endpoint should be accepting requests for Declaration protected void Verbs(params Http[] methods) Parameters Type Name Description Http [] methods Version(String) specify the version of the endpoint if versioning is enabled Declaration protected void Version(string version) Parameters Type Name Description System.String version the version value (without prefix) to associate with this endpoint"
  },
  "api/FastEndpoints.Endpoint-3.html": {
    "href": "api/FastEndpoints.Endpoint-3.html",
    "title": "Class Endpoint<TRequest, TResponse, TMapper> | FastEndpoints",
    "keywords": "Class Endpoint<TRequest, TResponse, TMapper> use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity using a seperate entity mapper. Inheritance System.Object BaseEndpoint Endpoint <TRequest, TResponse> Endpoint<TRequest, TResponse, TMapper> Inherited Members Endpoint<TRequest, TResponse>.HandleAsync(TRequest, CancellationToken) Endpoint<TRequest, TResponse>.TryResolve<TService>() Endpoint<TRequest, TResponse>.TryResolve(Type) Endpoint<TRequest, TResponse>.Resolve<TService>() Endpoint<TRequest, TResponse>.Resolve(Type) Endpoint<TRequest, TResponse>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<TRequest, TResponse>.OnBeforeValidate(TRequest) Endpoint<TRequest, TResponse>.OnBeforeValidateAsync(TRequest) Endpoint<TRequest, TResponse>.OnAfterValidate(TRequest) Endpoint<TRequest, TResponse>.OnAfterValidateAsync(TRequest) Endpoint<TRequest, TResponse>.OnBeforeHandle(TRequest) Endpoint<TRequest, TResponse>.OnBeforeHandleAsync(TRequest) Endpoint<TRequest, TResponse>.OnAfterHandle(TRequest, TResponse) Endpoint<TRequest, TResponse>.OnAfterHandleAsync(TRequest, TResponse) Endpoint<TRequest, TResponse>.ValidationFailed Endpoint<TRequest, TResponse>.User Endpoint<TRequest, TResponse>.Response Endpoint<TRequest, TResponse>.Config Endpoint<TRequest, TResponse>.Env Endpoint<TRequest, TResponse>.Logger Endpoint<TRequest, TResponse>.BaseURL Endpoint<TRequest, TResponse>.HttpMethod Endpoint<TRequest, TResponse>.Form Endpoint<TRequest, TResponse>.Files Endpoint<TRequest, TResponse>.SendAsync(TResponse, Int32, CancellationToken) Endpoint<TRequest, TResponse>.SendCreatedAtAsync<TEndpoint>(Object, TResponse, CancellationToken) Endpoint<TRequest, TResponse>.SendCreatedAtAsync(String, Object, TResponse, CancellationToken) Endpoint<TRequest, TResponse>.SendStringAsync(String, Int32, CancellationToken) Endpoint<TRequest, TResponse>.SendOkAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendErrorsAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendNoContentAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendNotFoundAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendUnauthorizedAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendForbiddenAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendBytesAsync(Byte[], String, String, CancellationToken) Endpoint<TRequest, TResponse>.SendFileAsync(FileInfo, String, CancellationToken) Endpoint<TRequest, TResponse>.SendStreamAsync(Stream, String, Nullable<Int64>, String, CancellationToken) Endpoint<TRequest, TResponse>.SendEmptyJsonObject(CancellationToken) Endpoint<TRequest, TResponse>.Get(String[]) Endpoint<TRequest, TResponse>.Post(String[]) Endpoint<TRequest, TResponse>.Put(String[]) Endpoint<TRequest, TResponse>.Patch(String[]) Endpoint<TRequest, TResponse>.Delete(String[]) Endpoint<TRequest, TResponse>.Routes(String[]) Endpoint<TRequest, TResponse>.Verbs(Http[]) Endpoint<TRequest, TResponse>.DontThrowIfValidationFails() Endpoint<TRequest, TResponse>.AllowAnonymous(Http[]) Endpoint<TRequest, TResponse>.AllowFileUploads() Endpoint<TRequest, TResponse>.AllowFormData() Endpoint<TRequest, TResponse>.Policies(String[]) Endpoint<TRequest, TResponse>.Roles(String[]) Endpoint<TRequest, TResponse>.Permissions(String[]) Endpoint<TRequest, TResponse>.PermissionsAll(String[]) Endpoint<TRequest, TResponse>.Claims(String[]) Endpoint<TRequest, TResponse>.ClaimsAll(String[]) Endpoint<TRequest, TResponse>.PreProcessors(IPreProcessor<TRequest>[]) Endpoint<TRequest, TResponse>.PostProcessors(IPostProcessor<TRequest, TResponse>[]) Endpoint<TRequest, TResponse>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<TRequest, TResponse>.Options(Action<RouteHandlerBuilder>) Endpoint<TRequest, TResponse>.Describe(Action<RouteHandlerBuilder>) Endpoint<TRequest, TResponse>.Tags(String[]) Endpoint<TRequest, TResponse>.Version(String) Endpoint<TRequest, TResponse>.AddError(String) Endpoint<TRequest, TResponse>.AddError(Expression<Func<TRequest, Object>>, String) Endpoint<TRequest, TResponse>.ThrowIfAnyErrors() Endpoint<TRequest, TResponse>.ThrowError(String) Endpoint<TRequest, TResponse>.ThrowError(Expression<Func<TRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.HttpContext BaseEndpoint.Configure() BaseEndpoint.ValidationFailures System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Endpoint<TRequest, TResponse, TMapper> : Endpoint<TRequest, TResponse>, IEndpoint, IServiceResolver where TRequest : class, new() where TResponse : new() where TMapper : IEntityMapper, new() Type Parameters Name Description TRequest the type of the request dto TResponse the type of the response dto TMapper the type of the entity mapper Properties Map the entity mapper for the endpoint HINT: entity mappers are singletons for performance reasons. do not maintain state in the mappers. Declaration public static TMapper Map { get; } Property Value Type Description TMapper"
  },
  "api/FastEndpoints.EndpointWithMapping-3.html": {
    "href": "api/FastEndpoints.EndpointWithMapping-3.html",
    "title": "Class EndpointWithMapping<TRequest, TResponse, TEntity> | FastEndpoints",
    "keywords": "Class EndpointWithMapping<TRequest, TResponse, TEntity> use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity. Inheritance System.Object BaseEndpoint Endpoint <TRequest, TResponse> EndpointWithMapping<TRequest, TResponse, TEntity> Inherited Members Endpoint<TRequest, TResponse>.HandleAsync(TRequest, CancellationToken) Endpoint<TRequest, TResponse>.TryResolve<TService>() Endpoint<TRequest, TResponse>.TryResolve(Type) Endpoint<TRequest, TResponse>.Resolve<TService>() Endpoint<TRequest, TResponse>.Resolve(Type) Endpoint<TRequest, TResponse>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<TRequest, TResponse>.OnBeforeValidate(TRequest) Endpoint<TRequest, TResponse>.OnBeforeValidateAsync(TRequest) Endpoint<TRequest, TResponse>.OnAfterValidate(TRequest) Endpoint<TRequest, TResponse>.OnAfterValidateAsync(TRequest) Endpoint<TRequest, TResponse>.OnBeforeHandle(TRequest) Endpoint<TRequest, TResponse>.OnBeforeHandleAsync(TRequest) Endpoint<TRequest, TResponse>.OnAfterHandle(TRequest, TResponse) Endpoint<TRequest, TResponse>.OnAfterHandleAsync(TRequest, TResponse) Endpoint<TRequest, TResponse>.ValidationFailed Endpoint<TRequest, TResponse>.User Endpoint<TRequest, TResponse>.Response Endpoint<TRequest, TResponse>.Config Endpoint<TRequest, TResponse>.Env Endpoint<TRequest, TResponse>.Logger Endpoint<TRequest, TResponse>.BaseURL Endpoint<TRequest, TResponse>.HttpMethod Endpoint<TRequest, TResponse>.Form Endpoint<TRequest, TResponse>.Files Endpoint<TRequest, TResponse>.SendAsync(TResponse, Int32, CancellationToken) Endpoint<TRequest, TResponse>.SendCreatedAtAsync<TEndpoint>(Object, TResponse, CancellationToken) Endpoint<TRequest, TResponse>.SendCreatedAtAsync(String, Object, TResponse, CancellationToken) Endpoint<TRequest, TResponse>.SendStringAsync(String, Int32, CancellationToken) Endpoint<TRequest, TResponse>.SendOkAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendErrorsAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendNoContentAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendNotFoundAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendUnauthorizedAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendForbiddenAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendBytesAsync(Byte[], String, String, CancellationToken) Endpoint<TRequest, TResponse>.SendFileAsync(FileInfo, String, CancellationToken) Endpoint<TRequest, TResponse>.SendStreamAsync(Stream, String, Nullable<Int64>, String, CancellationToken) Endpoint<TRequest, TResponse>.SendEmptyJsonObject(CancellationToken) Endpoint<TRequest, TResponse>.Get(String[]) Endpoint<TRequest, TResponse>.Post(String[]) Endpoint<TRequest, TResponse>.Put(String[]) Endpoint<TRequest, TResponse>.Patch(String[]) Endpoint<TRequest, TResponse>.Delete(String[]) Endpoint<TRequest, TResponse>.Routes(String[]) Endpoint<TRequest, TResponse>.Verbs(Http[]) Endpoint<TRequest, TResponse>.DontThrowIfValidationFails() Endpoint<TRequest, TResponse>.AllowAnonymous(Http[]) Endpoint<TRequest, TResponse>.AllowFileUploads() Endpoint<TRequest, TResponse>.AllowFormData() Endpoint<TRequest, TResponse>.Policies(String[]) Endpoint<TRequest, TResponse>.Roles(String[]) Endpoint<TRequest, TResponse>.Permissions(String[]) Endpoint<TRequest, TResponse>.PermissionsAll(String[]) Endpoint<TRequest, TResponse>.Claims(String[]) Endpoint<TRequest, TResponse>.ClaimsAll(String[]) Endpoint<TRequest, TResponse>.PreProcessors(IPreProcessor<TRequest>[]) Endpoint<TRequest, TResponse>.PostProcessors(IPostProcessor<TRequest, TResponse>[]) Endpoint<TRequest, TResponse>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<TRequest, TResponse>.Options(Action<RouteHandlerBuilder>) Endpoint<TRequest, TResponse>.Describe(Action<RouteHandlerBuilder>) Endpoint<TRequest, TResponse>.Tags(String[]) Endpoint<TRequest, TResponse>.Version(String) Endpoint<TRequest, TResponse>.AddError(String) Endpoint<TRequest, TResponse>.AddError(Expression<Func<TRequest, Object>>, String) Endpoint<TRequest, TResponse>.ThrowIfAnyErrors() Endpoint<TRequest, TResponse>.ThrowError(String) Endpoint<TRequest, TResponse>.ThrowError(Expression<Func<TRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.HttpContext BaseEndpoint.Configure() BaseEndpoint.ValidationFailures System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class EndpointWithMapping<TRequest, TResponse, TEntity> : Endpoint<TRequest, TResponse>, IEndpoint, IServiceResolver where TRequest : class, new() where TResponse : new() Type Parameters Name Description TRequest the type of the request dto TResponse the type of the response dto TEntity the type of domain entity that will be mapped to/from Methods MapFromEntity(TEntity) override this method and place the logic for mapping a domain entity to a response dto Declaration public virtual TResponse MapFromEntity(TEntity e) Parameters Type Name Description TEntity e the domain entity to map from Returns Type Description TResponse MapFromEntityAsync(TEntity) override this method and place the logic for mapping a domain entity to a response dto Declaration public virtual Task<TResponse> MapFromEntityAsync(TEntity e) Parameters Type Name Description TEntity e the domain entity to map from Returns Type Description Task <TResponse> MapToEntity(TRequest) override this method and place the logic for mapping the request dto to the desired domain entity Declaration public virtual TEntity MapToEntity(TRequest r) Parameters Type Name Description TRequest r the request dto Returns Type Description TEntity MapToEntityAsync(TRequest) override this method and place the logic for mapping the request dto to the desired domain entity Declaration public virtual Task<TEntity> MapToEntityAsync(TRequest r) Parameters Type Name Description TRequest r the request dto to map from Returns Type Description Task <TEntity>"
  },
  "api/FastEndpoints.EndpointWithoutRequest.html": {
    "href": "api/FastEndpoints.EndpointWithoutRequest.html",
    "title": "Class EndpointWithoutRequest | FastEndpoints",
    "keywords": "Class EndpointWithoutRequest use this base class for defining endpoints that doesn't need a request dto. usually used for routes that doesn't have any parameters. Inheritance System.Object BaseEndpoint Endpoint < EmptyRequest , System.Object > Endpoint < EmptyRequest > EndpointWithoutRequest Inherited Members Endpoint<EmptyRequest, Object>.HandleAsync(EmptyRequest, CancellationToken) Endpoint<EmptyRequest, Object>.TryResolve<TService>() Endpoint<EmptyRequest, Object>.TryResolve(Type) Endpoint<EmptyRequest, Object>.Resolve<TService>() Endpoint<EmptyRequest, Object>.Resolve(Type) Endpoint<EmptyRequest, Object>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<EmptyRequest, Object>.OnBeforeValidate(EmptyRequest) Endpoint<EmptyRequest, Object>.OnBeforeValidateAsync(EmptyRequest) Endpoint<EmptyRequest, Object>.OnAfterValidate(EmptyRequest) Endpoint<EmptyRequest, Object>.OnAfterValidateAsync(EmptyRequest) Endpoint<EmptyRequest, Object>.OnBeforeHandle(EmptyRequest) Endpoint<EmptyRequest, Object>.OnBeforeHandleAsync(EmptyRequest) Endpoint<EmptyRequest, Object>.OnAfterHandle(EmptyRequest, Object) Endpoint<EmptyRequest, Object>.OnAfterHandleAsync(EmptyRequest, Object) Endpoint<EmptyRequest, Object>.ValidationFailed Endpoint<EmptyRequest, Object>.User Endpoint<EmptyRequest, Object>.Response Endpoint<EmptyRequest, Object>.Config Endpoint<EmptyRequest, Object>.Env Endpoint<EmptyRequest, Object>.Logger Endpoint<EmptyRequest, Object>.BaseURL Endpoint<EmptyRequest, Object>.HttpMethod Endpoint<EmptyRequest, Object>.Form Endpoint<EmptyRequest, Object>.Files Endpoint<EmptyRequest, Object>.SendAsync(Object, Int32, CancellationToken) Endpoint<EmptyRequest, Object>.SendCreatedAtAsync<TEndpoint>(Object, Object, CancellationToken) Endpoint<EmptyRequest, Object>.SendCreatedAtAsync(String, Object, Object, CancellationToken) Endpoint<EmptyRequest, Object>.SendStringAsync(String, Int32, CancellationToken) Endpoint<EmptyRequest, Object>.SendOkAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendErrorsAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendNoContentAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendNotFoundAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendUnauthorizedAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendForbiddenAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendBytesAsync(Byte[], String, String, CancellationToken) Endpoint<EmptyRequest, Object>.SendFileAsync(FileInfo, String, CancellationToken) Endpoint<EmptyRequest, Object>.SendStreamAsync(Stream, String, Nullable<Int64>, String, CancellationToken) Endpoint<EmptyRequest, Object>.SendEmptyJsonObject(CancellationToken) Endpoint<EmptyRequest, Object>.Get(String[]) Endpoint<EmptyRequest, Object>.Post(String[]) Endpoint<EmptyRequest, Object>.Put(String[]) Endpoint<EmptyRequest, Object>.Patch(String[]) Endpoint<EmptyRequest, Object>.Delete(String[]) Endpoint<EmptyRequest, Object>.Routes(String[]) Endpoint<EmptyRequest, Object>.Verbs(Http[]) Endpoint<EmptyRequest, Object>.DontThrowIfValidationFails() Endpoint<EmptyRequest, Object>.AllowAnonymous(Http[]) Endpoint<EmptyRequest, Object>.AllowFileUploads() Endpoint<EmptyRequest, Object>.AllowFormData() Endpoint<EmptyRequest, Object>.Policies(String[]) Endpoint<EmptyRequest, Object>.Roles(String[]) Endpoint<EmptyRequest, Object>.Permissions(String[]) Endpoint<EmptyRequest, Object>.PermissionsAll(String[]) Endpoint<EmptyRequest, Object>.Claims(String[]) Endpoint<EmptyRequest, Object>.ClaimsAll(String[]) Endpoint<EmptyRequest, Object>.PreProcessors(IPreProcessor<EmptyRequest>[]) Endpoint<EmptyRequest, Object>.PostProcessors(IPostProcessor<EmptyRequest, Object>[]) Endpoint<EmptyRequest, Object>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<EmptyRequest, Object>.Options(Action<RouteHandlerBuilder>) Endpoint<EmptyRequest, Object>.Describe(Action<RouteHandlerBuilder>) Endpoint<EmptyRequest, Object>.Tags(String[]) Endpoint<EmptyRequest, Object>.Version(String) Endpoint<EmptyRequest, Object>.AddError(String) Endpoint<EmptyRequest, Object>.AddError(Expression<Func<EmptyRequest, Object>>, String) Endpoint<EmptyRequest, Object>.ThrowIfAnyErrors() Endpoint<EmptyRequest, Object>.ThrowError(String) Endpoint<EmptyRequest, Object>.ThrowError(Expression<Func<EmptyRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.HttpContext BaseEndpoint.Configure() BaseEndpoint.ValidationFailures System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class EndpointWithoutRequest : Endpoint<EmptyRequest>, IEndpoint, IServiceResolver"
  },
  "api/FastEndpoints.EndpointWithoutRequest-1.html": {
    "href": "api/FastEndpoints.EndpointWithoutRequest-1.html",
    "title": "Class EndpointWithoutRequest<TResponse> | FastEndpoints",
    "keywords": "Class EndpointWithoutRequest<TResponse> use this base class for defining endpoints that doesn't need a request dto but return a response dto. Inheritance System.Object BaseEndpoint Endpoint < EmptyRequest , TResponse> EndpointWithoutRequest<TResponse> Inherited Members Endpoint<EmptyRequest, TResponse>.HandleAsync(EmptyRequest, CancellationToken) Endpoint<EmptyRequest, TResponse>.TryResolve<TService>() Endpoint<EmptyRequest, TResponse>.TryResolve(Type) Endpoint<EmptyRequest, TResponse>.Resolve<TService>() Endpoint<EmptyRequest, TResponse>.Resolve(Type) Endpoint<EmptyRequest, TResponse>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<EmptyRequest, TResponse>.OnBeforeValidate(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnBeforeValidateAsync(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnAfterValidate(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnAfterValidateAsync(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnBeforeHandle(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnBeforeHandleAsync(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnAfterHandle(EmptyRequest, TResponse) Endpoint<EmptyRequest, TResponse>.OnAfterHandleAsync(EmptyRequest, TResponse) Endpoint<EmptyRequest, TResponse>.ValidationFailed Endpoint<EmptyRequest, TResponse>.User Endpoint<EmptyRequest, TResponse>.Response Endpoint<EmptyRequest, TResponse>.Config Endpoint<EmptyRequest, TResponse>.Env Endpoint<EmptyRequest, TResponse>.Logger Endpoint<EmptyRequest, TResponse>.BaseURL Endpoint<EmptyRequest, TResponse>.HttpMethod Endpoint<EmptyRequest, TResponse>.Form Endpoint<EmptyRequest, TResponse>.Files Endpoint<EmptyRequest, TResponse>.SendAsync(TResponse, Int32, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendCreatedAtAsync<TEndpoint>(Object, TResponse, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendCreatedAtAsync(String, Object, TResponse, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendStringAsync(String, Int32, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendOkAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendErrorsAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendNoContentAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendNotFoundAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendUnauthorizedAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendForbiddenAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendBytesAsync(Byte[], String, String, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendFileAsync(FileInfo, String, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendStreamAsync(Stream, String, Nullable<Int64>, String, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendEmptyJsonObject(CancellationToken) Endpoint<EmptyRequest, TResponse>.Get(String[]) Endpoint<EmptyRequest, TResponse>.Post(String[]) Endpoint<EmptyRequest, TResponse>.Put(String[]) Endpoint<EmptyRequest, TResponse>.Patch(String[]) Endpoint<EmptyRequest, TResponse>.Delete(String[]) Endpoint<EmptyRequest, TResponse>.Routes(String[]) Endpoint<EmptyRequest, TResponse>.Verbs(Http[]) Endpoint<EmptyRequest, TResponse>.DontThrowIfValidationFails() Endpoint<EmptyRequest, TResponse>.AllowAnonymous(Http[]) Endpoint<EmptyRequest, TResponse>.AllowFileUploads() Endpoint<EmptyRequest, TResponse>.AllowFormData() Endpoint<EmptyRequest, TResponse>.Policies(String[]) Endpoint<EmptyRequest, TResponse>.Roles(String[]) Endpoint<EmptyRequest, TResponse>.Permissions(String[]) Endpoint<EmptyRequest, TResponse>.PermissionsAll(String[]) Endpoint<EmptyRequest, TResponse>.Claims(String[]) Endpoint<EmptyRequest, TResponse>.ClaimsAll(String[]) Endpoint<EmptyRequest, TResponse>.PreProcessors(IPreProcessor<EmptyRequest>[]) Endpoint<EmptyRequest, TResponse>.PostProcessors(IPostProcessor<EmptyRequest, TResponse>[]) Endpoint<EmptyRequest, TResponse>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<EmptyRequest, TResponse>.Options(Action<RouteHandlerBuilder>) Endpoint<EmptyRequest, TResponse>.Describe(Action<RouteHandlerBuilder>) Endpoint<EmptyRequest, TResponse>.Tags(String[]) Endpoint<EmptyRequest, TResponse>.Version(String) Endpoint<EmptyRequest, TResponse>.AddError(String) Endpoint<EmptyRequest, TResponse>.AddError(Expression<Func<EmptyRequest, Object>>, String) Endpoint<EmptyRequest, TResponse>.ThrowIfAnyErrors() Endpoint<EmptyRequest, TResponse>.ThrowError(String) Endpoint<EmptyRequest, TResponse>.ThrowError(Expression<Func<EmptyRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.HttpContext BaseEndpoint.Configure() BaseEndpoint.ValidationFailures System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class EndpointWithoutRequest<TResponse> : Endpoint<EmptyRequest, TResponse>, IEndpoint, IServiceResolver where TResponse : class, new() Type Parameters Name Description TResponse the type of the response dto"
  },
  "api/FastEndpoints.ErrorResponse.html": {
    "href": "api/FastEndpoints.ErrorResponse.html",
    "title": "Class ErrorResponse | FastEndpoints",
    "keywords": "Class ErrorResponse the dto used to send an error response to the client Inheritance System.Object ErrorResponse Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public sealed class ErrorResponse Constructors ErrorResponse() instantiate a new error response without any errors Declaration public ErrorResponse() ErrorResponse(IEnumerable<ValidationFailure>) instantiate an error response with the given collection validation failures Declaration public ErrorResponse(IEnumerable<ValidationFailure> failures) Parameters Type Name Description IEnumerable < ValidationFailure > failures Properties Errors the collection of errors for the current context Declaration public Dictionary<string, IEnumerable<string>> Errors { get; set; } Property Value Type Description Dictionary < System.String , IEnumerable < System.String >> Message the message for the error response Declaration public string Message { get; set; } Property Value Type Description System.String StatusCode the http status code sent to the client. default is 400. Declaration public int StatusCode { get; set; } Property Value Type Description System.Int32"
  },
  "api/FastEndpoints.Event-1.html": {
    "href": "api/FastEndpoints.Event-1.html",
    "title": "Class Event<TEvent> | FastEndpoints",
    "keywords": "Class Event<TEvent> event notification hub which uses an in-process pub/sub messaging system based on .net events Inheritance System.Object Event<TEvent> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class Event<TEvent> where TEvent : class Type Parameters Name Description TEvent the type of notification event Methods PublishAsync(TEvent, Mode, CancellationToken) publish the given model/dto to all the subscribers of the event notification Declaration public static Task PublishAsync(TEvent eventModel, Mode waitMode = Mode.WaitForAll, CancellationToken cancellation = null) Parameters Type Name Description TEvent eventModel the notification event model/dto to publish Mode waitMode specify whether to wait for none, any or all of the subscribers to complete their work CancellationToken cancellation an optional cancellation token Returns Type Description Task a Task that matches the wait mode specified. Mode.WaitForNone returns an already completed Task (fire and forget). Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work. Mode.WaitForAll return a Task that will complete only when all of the subscribers complete their work."
  },
  "api/FastEndpoints.ExceptionHandlerExtensions.html": {
    "href": "api/FastEndpoints.ExceptionHandlerExtensions.html",
    "title": "Class ExceptionHandlerExtensions | FastEndpoints",
    "keywords": "Class ExceptionHandlerExtensions extensions for global exception handling Inheritance System.Object ExceptionHandlerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class ExceptionHandlerExtensions Methods UseDefaultExceptionHandler(IApplicationBuilder, ILogger) registers the default global exception handler which will log the exceptions on the server and return a user-friendly json response to the client when unhandled exceptions occur. TIP: when using this exception handler, you may want to turn off the asp.net core exception middleware logging to avoid duplication like so: \"Logging\": { \"LogLevel\": { \"Default\": \"Warning\", \"Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware\": \"None\" } } Declaration public static void UseDefaultExceptionHandler(this IApplicationBuilder app, ILogger logger = null) Parameters Type Name Description Microsoft.AspNetCore.Builder.IApplicationBuilder app Microsoft.Extensions.Logging.ILogger logger an optional logger instance"
  },
  "api/FastEndpoints.FastEventHandler-1.html": {
    "href": "api/FastEndpoints.FastEventHandler-1.html",
    "title": "Class FastEventHandler<TEvent> | FastEndpoints",
    "keywords": "Class FastEventHandler<TEvent> use this base class to handle events published by the notification system Inheritance System.Object FastEventHandler<TEvent> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class FastEventHandler<TEvent> : IEventHandler, IServiceResolver where TEvent : class, new() Type Parameters Name Description TEvent the type of the event to handle Methods HandleAsync(TEvent, CancellationToken) this method will be called when an event of the specified type is published. Declaration public abstract Task HandleAsync(TEvent eventModel, CancellationToken ct) Parameters Type Name Description TEvent eventModel the event model/dto received CancellationToken ct an optional cancellation token Returns Type Description Task PublishAsync<TEventModel>(TEventModel, Mode, CancellationToken) publish the given model/dto to all the subscribers of the event notification Declaration public Task PublishAsync<TEventModel>(TEventModel eventModel, Mode waitMode = Mode.WaitForAll, CancellationToken cancellation = null) where TEventModel : class Parameters Type Name Description TEventModel eventModel the notification event model/dto to publish Mode waitMode specify whether to wait for none, any or all of the subscribers to complete their work CancellationToken cancellation an optional cancellation token Returns Type Description Task a Task that matches the wait mode specified. Mode.WaitForNone returns an already completed Task (fire and forget). Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work. Mode.WaitForAll return a Task that will complete only when all of the subscribers complete their work. Type Parameters Name Description TEventModel Resolve(Type) resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public object Resolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object Resolve<TService>() resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public TService Resolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve TryResolve(Type) try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public object TryResolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object TryResolve<TService>() try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public TService TryResolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve"
  },
  "api/FastEndpoints.FromAttribute.html": {
    "href": "api/FastEndpoints.FromAttribute.html",
    "title": "Class FromAttribute | FastEndpoints",
    "keywords": "Class FromAttribute properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal. this is a shorter alias for the [FromClaim] attribute. Inheritance System.Object FromClaimAttribute FromAttribute Inherited Members FromClaimAttribute.ClaimType FromClaimAttribute.IsRequired Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class FromAttribute : FromClaimAttribute Constructors FromAttribute(String, Boolean) properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal. this is a shorter alias for the [FromClaim] attribute. Declaration public FromAttribute(string claimType, bool isRequired = true) Parameters Type Name Description System.String claimType the claim type to auto bind System.Boolean isRequired set to true if a validation error should be thrown when the current user principal doesn't have the specified claim"
  },
  "api/FastEndpoints.FromClaimAttribute.html": {
    "href": "api/FastEndpoints.FromClaimAttribute.html",
    "title": "Class FromClaimAttribute | FastEndpoints",
    "keywords": "Class FromClaimAttribute properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal Inheritance System.Object FromClaimAttribute FromAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class FromClaimAttribute : Attribute Constructors FromClaimAttribute(Boolean) properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal Declaration public FromClaimAttribute(bool isRequired) Parameters Type Name Description System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current user principal doesn't have a claim type matching the property name being bound to. FromClaimAttribute(String, Boolean) properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal Declaration public FromClaimAttribute(string claimType = null, bool isRequired = true) Parameters Type Name Description System.String claimType optionally specify the claim type to bind from. if not specified, the claim type of the user principal must match the name of the property being bound to. System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current user principal doesn't have the specified claim type Properties ClaimType the claim type to auto bind Declaration public string ClaimType { get; set; } Property Value Type Description System.String IsRequired set to true if a validation error should be thrown when the current user principal doesn't have the specified claim Declaration public bool IsRequired { get; set; } Property Value Type Description System.Boolean"
  },
  "api/FastEndpoints.FromHeaderAttribute.html": {
    "href": "api/FastEndpoints.FromHeaderAttribute.html",
    "title": "Class FromHeaderAttribute | FastEndpoints",
    "keywords": "Class FromHeaderAttribute properties decorated with this attribute will have their values auto bound from the relevant http header of the current request. Inheritance System.Object FromHeaderAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class FromHeaderAttribute : Attribute Constructors FromHeaderAttribute(Boolean) properties decorated with this attribute will have their values auto bound from the relevant http header of the current request. Declaration public FromHeaderAttribute(bool isRequired) Parameters Type Name Description System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current user request doesn't have a header matching the property name being bound to. FromHeaderAttribute(String, Boolean) properties decorated with this attribute will have their values auto bound from the relevant http header of the current request. Declaration public FromHeaderAttribute(string headerName = null, bool isRequired = true) Parameters Type Name Description System.String headerName optionally specify the header name to bind from. if not specified, the header name must match the name of the property being bound to. System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current request doesn't have the specified header. Properties HeaderName the header name to auto bind from Declaration public string HeaderName { get; set; } Property Value Type Description System.String IsRequired set to true if a validation error should be thrown when the current request doesn't have the specified header Declaration public bool IsRequired { get; set; } Property Value Type Description System.Boolean"
  },
  "api/FastEndpoints.html": {
    "href": "api/FastEndpoints.html",
    "title": "Namespace FastEndpoints | FastEndpoints",
    "keywords": "Namespace FastEndpoints Classes BaseEndpoint Config global configuration settings for FastEndpoints DiscoveredEndpoint represents an endpoint that has been discovered during startup EmptyRequest a request dto that doesn't have any properties EmptyResponse a response dto that doesn't have any properties Endpoint<TRequest> use this base class for defining endpoints that only use a request dto and don't use a response dto. Endpoint<TRequest, TResponse> use this base class for defining endpoints that use both request and response dtos. Endpoint<TRequest, TResponse, TMapper> use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity using a seperate entity mapper. EndpointWithMapping<TRequest, TResponse, TEntity> use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity. EndpointWithoutRequest use this base class for defining endpoints that doesn't need a request dto. usually used for routes that doesn't have any parameters. EndpointWithoutRequest<TResponse> use this base class for defining endpoints that doesn't need a request dto but return a response dto. ErrorResponse the dto used to send an error response to the client Event<TEvent> event notification hub which uses an in-process pub/sub messaging system based on .net events ExceptionHandlerExtensions extensions for global exception handling FastEventHandler<TEvent> use this base class to handle events published by the notification system FromAttribute properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal. this is a shorter alias for the [FromClaim] attribute. FromClaimAttribute properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal FromHeaderAttribute properties decorated with this attribute will have their values auto bound from the relevant http header of the current request. HttpClientExtensions a set of extensions to the httpclient in order to facilitate route-less integration testing HttpResponseExtensions MainExtensions provides extensions to easily bootstrap fastendpoints in the asp.net middleware pipeline Mapper<TRequest, TResponse, TEntity> use this base class to define domain entity mappers for your endpoints. HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers. PlainTextRequest use this dto if you need to model bind the raw content body of an incoming http request or you may implement the IPlainTextRequest interface on your own request dto. RoutingOptions routing options for the endpoints VersioningOptions global endpoint versioning options Interfaces IEntityMapper marker interface for entity mappers IPlainTextRequest implement this interface on your request dto if you need to model bind the raw content body of an incoming http request IPostProcessor<TRequest, TResponse> interface for defining post-processors to be executed after the main endpoint handler is done IPreProcessor<TRequest> interface for defining pre-processors to be executed before the main endpoint handler is called Enums Http enum for specifying a http verb Mode enum for specifying the waiting mode for event notifications"
  },
  "api/FastEndpoints.Http.html": {
    "href": "api/FastEndpoints.Http.html",
    "title": "Enum Http | FastEndpoints",
    "keywords": "Enum Http enum for specifying a http verb Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public enum Http Fields Name Description DELETE remove a record GET retrieve a record PATCH partially update a record POST create a record PUT replace a record"
  },
  "api/FastEndpoints.HttpClientExtensions.html": {
    "href": "api/FastEndpoints.HttpClientExtensions.html",
    "title": "Class HttpClientExtensions | FastEndpoints",
    "keywords": "Class HttpClientExtensions a set of extensions to the httpclient in order to facilitate route-less integration testing Inheritance System.Object HttpClientExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class HttpClientExtensions Methods GETAsync<TEndpoint, TResponse>(HttpClient) make a GET request to an endpoint using auto route discovery without a request dto and get back a typed response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> GETAsync<TEndpoint, TResponse>(this HttpClient client) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TResponse the type of the response dto GETAsync<TEndpoint, TRequest>(HttpClient, TRequest) make a GET request to an endpoint using auto route discovery using a request dto that does not send back a response dto. Declaration public static async Task<HttpResponseMessage?> GETAsync<TEndpoint, TRequest>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.Nullable < HttpResponseMessage >> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto GETAsync<TRequest, TResponse>(HttpClient, String, TRequest) make a GET request using a request dto and get back a response dto. Declaration public static async Task<(HttpResponseMessage? response, TResponse result)> GETAsync<TRequest, TResponse>(this HttpClient client, string requestUri, TRequest request) Parameters Type Name Description HttpClient client System.String requestUri the route url to post to TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TRequest type of the requet dto TResponse type of the response dto GETAsync<TEndpoint, TRequest, TResponse>(HttpClient, TRequest) make a GET request to an endpoint using auto route discovery using a request dto and get back a response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> GETAsync<TEndpoint, TRequest, TResponse>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto TResponse the type of the response dto POSTAsync<TEndpoint, TResponse>(HttpClient) make a POST request to an endpoint using auto route discovery without a request dto and get back a typed response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> POSTAsync<TEndpoint, TResponse>(this HttpClient client) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TResponse the type of the response dto POSTAsync<TEndpoint, TRequest>(HttpClient, TRequest) make a POST request to an endpoint using auto route discovery using a request dto that does not send back a response dto. Declaration public static async Task<HttpResponseMessage?> POSTAsync<TEndpoint, TRequest>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.Nullable < HttpResponseMessage >> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto POSTAsync<TRequest, TResponse>(HttpClient, String, TRequest) make a POST request using a request dto and get back a response dto. Declaration public static async Task<(HttpResponseMessage? response, TResponse result)> POSTAsync<TRequest, TResponse>(this HttpClient client, string requestUri, TRequest request) Parameters Type Name Description HttpClient client System.String requestUri the route url to post to TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TRequest type of the requet dto TResponse type of the response dto POSTAsync<TEndpoint, TRequest, TResponse>(HttpClient, TRequest) make a POST request to an endpoint using auto route discovery using a request dto and get back a response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> POSTAsync<TEndpoint, TRequest, TResponse>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto TResponse the type of the response dto PUTAsync<TEndpoint, TResponse>(HttpClient) make a PUT request to an endpoint using auto route discovery without a request dto and get back a typed response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> PUTAsync<TEndpoint, TResponse>(this HttpClient client) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TResponse the type of the response dto PUTAsync<TEndpoint, TRequest>(HttpClient, TRequest) make a PUT request to an endpoint using auto route discovery using a request dto that does not send back a response dto. Declaration public static async Task<HttpResponseMessage?> PUTAsync<TEndpoint, TRequest>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.Nullable < HttpResponseMessage >> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto PUTAsync<TRequest, TResponse>(HttpClient, String, TRequest) make a PUT request using a request dto and get back a response dto. Declaration public static async Task<(HttpResponseMessage? response, TResponse result)> PUTAsync<TRequest, TResponse>(this HttpClient client, string requestUri, TRequest request) Parameters Type Name Description HttpClient client System.String requestUri the route url to post to TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TRequest type of the requet dto TResponse type of the response dto PUTAsync<TEndpoint, TRequest, TResponse>(HttpClient, TRequest) make a PUT request to an endpoint using auto route discovery using a request dto and get back a response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> PUTAsync<TEndpoint, TRequest, TResponse>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint, new() Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto TResponse the type of the response dto"
  },
  "api/FastEndpoints.HttpResponseExtensions.html": {
    "href": "api/FastEndpoints.HttpResponseExtensions.html",
    "title": "Class HttpResponseExtensions | FastEndpoints",
    "keywords": "Class HttpResponseExtensions Inheritance System.Object HttpResponseExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class HttpResponseExtensions Methods SendAsync<TResponse>(HttpResponse, TResponse, Int32, CancellationToken) send the supplied response dto serialized as json to the client. Declaration public static Task SendAsync<TResponse>(this HttpResponse rsp, TResponse response, int statusCode = 200, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp TResponse response the object to serialize to json System.Int32 statusCode optional custom http status code CancellationToken cancellation optional cancellation token Returns Type Description Task Type Parameters Name Description TResponse SendBytesAsync(HttpResponse, Byte[], String, String, CancellationToken) send a byte array to the client Declaration public static async Task SendBytesAsync(this HttpResponse rsp, byte[] bytes, string fileName = null, string contentType = \"application/octet-stream\", CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.Byte [] bytes the bytes to send System.String fileName System.String contentType optional content type to set on the http response CancellationToken cancellation optional cancellation token Returns Type Description Task SendCreatedAtAsync(HttpResponse, String, Object, Object, CancellationToken) send a 201 created response with a location header containing where the resource can be retrieved from. WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi route endpoint. Declaration public static Task SendCreatedAtAsync(this HttpResponse rsp, string endpointName, object routeValues, object responseBody, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.String endpointName the name of the endpoint to use for link generation (openapi route id) System.Object routeValues a route values object with key/value pairs of route information System.Object responseBody the content to be serialized in the response body CancellationToken cancellation cancellation token Returns Type Description Task SendCreatedAtAsync<TEndpoint>(HttpResponse, Object, Object, CancellationToken) send a 201 created response with a location header containing where the resource can be retrieved from. WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi route endpoint. Declaration public static Task SendCreatedAtAsync<TEndpoint>(this HttpResponse rsp, object routeValues, object responseBody, CancellationToken cancellation = null) where TEndpoint : IEndpoint Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.Object routeValues a route values object with key/value pairs of route information System.Object responseBody the content to be serialized in the response body CancellationToken cancellation cancellation token Returns Type Description Task Type Parameters Name Description TEndpoint the type of the endpoint where the resource can be retrieved from SendEmptyJsonObject(HttpResponse, CancellationToken) send an empty json object in the body Declaration public static Task SendEmptyJsonObject(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token Returns Type Description Task SendErrorsAsync(HttpResponse, List<ValidationFailure>, CancellationToken) send a 400 bad request with error details of the current validation failures Declaration public static Task SendErrorsAsync(this HttpResponse rsp, List<ValidationFailure> failures, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp List < ValidationFailure > failures CancellationToken cancellation Returns Type Description Task SendFileAsync(HttpResponse, FileInfo, String, CancellationToken) send a file to the client Declaration public static Task SendFileAsync(this HttpResponse rsp, FileInfo fileInfo, string contentType = \"application/octet-stream\", CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp FileInfo fileInfo System.String contentType optional content type to set on the http response CancellationToken cancellation optional cancellation token Returns Type Description Task SendForbiddenAsync(HttpResponse, CancellationToken) send a 403 unauthorized response Declaration public static Task SendForbiddenAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token Returns Type Description Task SendNoContentAsync(HttpResponse, CancellationToken) send a 204 no content response Declaration public static Task SendNoContentAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token Returns Type Description Task SendNotFoundAsync(HttpResponse, CancellationToken) send a 404 not found response Declaration public static Task SendNotFoundAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token Returns Type Description Task SendOkAsync(HttpResponse, CancellationToken) send an http 200 ok response without any body Declaration public static Task SendOkAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token Returns Type Description Task SendStreamAsync(HttpResponse, Stream, String, Nullable<Int64>, String, CancellationToken) send the contents of a stream to the client Declaration public static Task SendStreamAsync(this HttpResponse rsp, Stream stream, string fileName = null, long? fileLengthBytes = null, string contentType = \"application/octet-stream\", CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp Stream stream the stream to read the data from System.String fileName and optional file name to set in the content-disposition header System.Nullable < System.Int64 > fileLengthBytes optional total size of the file/stream System.String contentType optional content type to set on the http response CancellationToken cancellation optional cancellation token Returns Type Description Task SendStringAsync(HttpResponse, String, Int32, CancellationToken) send the supplied string content to the client. Declaration public static Task SendStringAsync(this HttpResponse rsp, string content, int statusCode = 200, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.String content the string to write to the response body System.Int32 statusCode optional custom http status code CancellationToken cancellation optional cancellation token Returns Type Description Task SendUnauthorizedAsync(HttpResponse, CancellationToken) send a 401 unauthorized response Declaration public static Task SendUnauthorizedAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token Returns Type Description Task"
  },
  "api/FastEndpoints.IEntityMapper.html": {
    "href": "api/FastEndpoints.IEntityMapper.html",
    "title": "Interface IEntityMapper | FastEndpoints",
    "keywords": "Interface IEntityMapper marker interface for entity mappers Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public interface IEntityMapper"
  },
  "api/FastEndpoints.IPlainTextRequest.html": {
    "href": "api/FastEndpoints.IPlainTextRequest.html",
    "title": "Interface IPlainTextRequest | FastEndpoints",
    "keywords": "Interface IPlainTextRequest implement this interface on your request dto if you need to model bind the raw content body of an incoming http request Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public interface IPlainTextRequest Properties Content the request body content will be bound to this property Declaration string Content { get; set; } Property Value Type Description System.String"
  },
  "api/FastEndpoints.IPostProcessor-2.html": {
    "href": "api/FastEndpoints.IPostProcessor-2.html",
    "title": "Interface IPostProcessor<TRequest, TResponse> | FastEndpoints",
    "keywords": "Interface IPostProcessor<TRequest, TResponse> interface for defining post-processors to be executed after the main endpoint handler is done Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public interface IPostProcessor<TRequest, TResponse> Type Parameters Name Description TRequest the type of the request dto TResponse the type of the response dto Methods PostProcessAsync(TRequest, TResponse, HttpContext, IReadOnlyCollection<ValidationFailure>, CancellationToken) Declaration Task PostProcessAsync(TRequest req, TResponse res, HttpContext ctx, IReadOnlyCollection<ValidationFailure> failures, CancellationToken ct) Parameters Type Name Description TRequest req TResponse res Microsoft.AspNetCore.Http.HttpContext ctx IReadOnlyCollection < ValidationFailure > failures CancellationToken ct Returns Type Description Task"
  },
  "api/FastEndpoints.IPreProcessor-1.html": {
    "href": "api/FastEndpoints.IPreProcessor-1.html",
    "title": "Interface IPreProcessor<TRequest> | FastEndpoints",
    "keywords": "Interface IPreProcessor<TRequest> interface for defining pre-processors to be executed before the main endpoint handler is called Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public interface IPreProcessor<TRequest> Type Parameters Name Description TRequest the type of the request dto Methods PreProcessAsync(TRequest, HttpContext, List<ValidationFailure>, CancellationToken) Declaration Task PreProcessAsync(TRequest req, HttpContext ctx, List<ValidationFailure> failures, CancellationToken ct) Parameters Type Name Description TRequest req Microsoft.AspNetCore.Http.HttpContext ctx List < ValidationFailure > failures CancellationToken ct Returns Type Description Task"
  },
  "api/FastEndpoints.MainExtensions.html": {
    "href": "api/FastEndpoints.MainExtensions.html",
    "title": "Class MainExtensions | FastEndpoints",
    "keywords": "Class MainExtensions provides extensions to easily bootstrap fastendpoints in the asp.net middleware pipeline Inheritance System.Object MainExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class MainExtensions Methods AddFastEndpoints(IServiceCollection) adds the FastEndpoints services to the ASP.Net middleware pipeline Declaration public static IServiceCollection AddFastEndpoints(this IServiceCollection services) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection UseFastEndpoints(IEndpointRouteBuilder, Nullable<Action<Config>>) finalizes auto discovery of endpoints and prepares FastEndpoints to start processing requests Declaration public static IEndpointRouteBuilder UseFastEndpoints(this IEndpointRouteBuilder builder, Action<Config>? configAction = null) Parameters Type Name Description Microsoft.AspNetCore.Routing.IEndpointRouteBuilder builder System.Nullable < Action < Config >> configAction an optional action to configure FastEndpoints Returns Type Description Microsoft.AspNetCore.Routing.IEndpointRouteBuilder"
  },
  "api/FastEndpoints.Mapper-3.html": {
    "href": "api/FastEndpoints.Mapper-3.html",
    "title": "Class Mapper<TRequest, TResponse, TEntity> | FastEndpoints",
    "keywords": "Class Mapper<TRequest, TResponse, TEntity> use this base class to define domain entity mappers for your endpoints. HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers. Inheritance System.Object Mapper<TRequest, TResponse, TEntity> Implements IEntityMapper Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Mapper<TRequest, TResponse, TEntity> : IEntityMapper, IServiceResolver where TRequest : new() where TResponse : new() Type Parameters Name Description TRequest the type of request dto TResponse the type of response dto TEntity the type of domain entity to map to/from Methods FromEntity(TEntity) override this method and place the logic for mapping a domain entity to a response dto Declaration public virtual TResponse FromEntity(TEntity e) Parameters Type Name Description TEntity e the domain entity to map from Returns Type Description TResponse FromEntityAsync(TEntity) override this method and place the logic for mapping a domain entity to a response dto Declaration public virtual Task<TResponse> FromEntityAsync(TEntity e) Parameters Type Name Description TEntity e the domain entity to map from Returns Type Description Task <TResponse> Resolve(Type) resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public object Resolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object Resolve<TService>() resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public TService Resolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve ToEntity(TRequest) override this method and place the logic for mapping the request dto to the desired domain entity Declaration public virtual TEntity ToEntity(TRequest r) Parameters Type Name Description TRequest r the request dto Returns Type Description TEntity ToEntityAsync(TRequest) override this method and place the logic for mapping the request dto to the desired domain entity Declaration public virtual Task<TEntity> ToEntityAsync(TRequest r) Parameters Type Name Description TRequest r the request dto to map from Returns Type Description Task <TEntity> TryResolve(Type) try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public object TryResolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object TryResolve<TService>() try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public TService TryResolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve Implements IEntityMapper"
  },
  "api/FastEndpoints.Mode.html": {
    "href": "api/FastEndpoints.Mode.html",
    "title": "Enum Mode | FastEndpoints",
    "keywords": "Enum Mode enum for specifying the waiting mode for event notifications Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public enum Mode Fields Name Description WaitForAll return a Task that will complete only when all of the subscribers complete their work WaitForAny returns a Task that will complete when any of the subscribers complete their work WaitForNone returns an already completed Task (fire and forget)"
  },
  "api/FastEndpoints.NSwag.Extensions.html": {
    "href": "api/FastEndpoints.NSwag.Extensions.html",
    "title": "Class Extensions | FastEndpoints",
    "keywords": "Class Extensions a set of extension methods for adding swagger support Inheritance System.Object Extensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.NSwag Assembly : FastEndpoints.NSwag.dll Syntax public static class Extensions Methods AddNSwag(IServiceCollection, Nullable<Action<AspNetCoreOpenApiDocumentGeneratorSettings>>, Nullable<Action<JsonOptions>>, Boolean, Int32) enable swagger support for FastEndpoints with a single call. Declaration public static IServiceCollection AddNSwag(this IServiceCollection services, Action<AspNetCoreOpenApiDocumentGeneratorSettings>? settings = null, Action<JsonOptions>? serializerOptions = null, bool addJWTBearerAuth = true, int tagIndex = 1) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services System.Nullable < Action < NSwag.Generation.AspNetCore.AspNetCoreOpenApiDocumentGeneratorSettings >> settings swaggergen config settings System.Nullable < Action < Microsoft.AspNetCore.Mvc.JsonOptions >> serializerOptions json serializer options System.Boolean addJWTBearerAuth set to false to disable auto addition of jwt bearer auth support System.Int32 tagIndex the index of the route path segment to use for tagging/grouping endpoints Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection ConfigureDefaults(SwaggerUi3Settings) configure swagger ui with some sensible defaults for FastEndpoints which can be overridden if needed. Declaration public static void ConfigureDefaults(this SwaggerUi3Settings s) Parameters Type Name Description NSwag.AspNetCore.SwaggerUi3Settings s EnableFastEndpoints(AspNetCoreOpenApiDocumentGeneratorSettings, Int32) enable support for FastEndpoints in swagger Declaration public static void EnableFastEndpoints(this AspNetCoreOpenApiDocumentGeneratorSettings settings, int tagIndex) Parameters Type Name Description NSwag.Generation.AspNetCore.AspNetCoreOpenApiDocumentGeneratorSettings settings System.Int32 tagIndex the index of the route path segment to use for tagging/grouping endpoints EnableJWTBearerAuth(AspNetCoreOpenApiDocumentGeneratorSettings) enable jwt bearer authorization support Declaration public static void EnableJWTBearerAuth(this AspNetCoreOpenApiDocumentGeneratorSettings settings) Parameters Type Name Description NSwag.Generation.AspNetCore.AspNetCoreOpenApiDocumentGeneratorSettings settings"
  },
  "api/FastEndpoints.NSwag.html": {
    "href": "api/FastEndpoints.NSwag.html",
    "title": "Namespace FastEndpoints.NSwag | FastEndpoints",
    "keywords": "Namespace FastEndpoints.NSwag Classes Extensions a set of extension methods for adding swagger support"
  },
  "api/FastEndpoints.PlainTextRequest.html": {
    "href": "api/FastEndpoints.PlainTextRequest.html",
    "title": "Class PlainTextRequest | FastEndpoints",
    "keywords": "Class PlainTextRequest use this dto if you need to model bind the raw content body of an incoming http request or you may implement the IPlainTextRequest interface on your own request dto. Inheritance System.Object PlainTextRequest Implements IPlainTextRequest Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class PlainTextRequest : IPlainTextRequest Properties Content the body content of the incoming request Declaration public string Content { get; set; } Property Value Type Description System.String Implements IPlainTextRequest"
  },
  "api/FastEndpoints.RoutingOptions.html": {
    "href": "api/FastEndpoints.RoutingOptions.html",
    "title": "Class RoutingOptions | FastEndpoints",
    "keywords": "Class RoutingOptions routing options for the endpoints Inheritance System.Object RoutingOptions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class RoutingOptions Properties Prefix prefix for all routes (example 'api'). Declaration public string Prefix { get; set; } Property Value Type Description System.String"
  },
  "api/FastEndpoints.Security.AuthExtensions.html": {
    "href": "api/FastEndpoints.Security.AuthExtensions.html",
    "title": "Class AuthExtensions | FastEndpoints",
    "keywords": "Class AuthExtensions a set of auth related extensions Inheritance System.Object AuthExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.Security Assembly : FastEndpoints.Security.dll Syntax public static class AuthExtensions Methods AddAuthenticationJWTBearer(IServiceCollection, String) configure and enable jwt bearer authentication Declaration public static IServiceCollection AddAuthenticationJWTBearer(this IServiceCollection services, string tokenSigningKey) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services System.String tokenSigningKey the secret key to use for verifying the jwt tokens Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection ClaimValue(ClaimsPrincipal, String) get the claim value for a given claim type of the current user principal. if the user doesn't have the requested claim type, a null will be returned. Declaration public static string ClaimValue(this ClaimsPrincipal principal, string claimType) Parameters Type Name Description System.Security.Claims.ClaimsPrincipal principal System.String claimType the claim type to look for Returns Type Description System.String HasClaimType(ClaimsPrincipal, String) determines if the current user principal has the given claim type Declaration public static bool HasClaimType(this ClaimsPrincipal principal, string claimType) Parameters Type Name Description System.Security.Claims.ClaimsPrincipal principal System.String claimType the claim type to check for Returns Type Description System.Boolean HasPermission(ClaimsPrincipal, String) returns true of the current user principal has a given permission code. Declaration public static bool HasPermission(this ClaimsPrincipal principal, string permissionCode) Parameters Type Name Description System.Security.Claims.ClaimsPrincipal principal System.String permissionCode the permission code to check for Returns Type Description System.Boolean"
  },
  "api/FastEndpoints.Security.html": {
    "href": "api/FastEndpoints.Security.html",
    "title": "Namespace FastEndpoints.Security | FastEndpoints",
    "keywords": "Namespace FastEndpoints.Security Classes AuthExtensions a set of auth related extensions JWTBearer static class for easy creation of jwt bearer auth tokens Permissions inherit from this class and define your applications permissions as public const string public const string Inventory_Create_Item = \"100\"; public const string Inventory_Retrieve_Item = \"101\"; public const string Inventory_Update_Item = \"102\"; public const string Inventory_Delete_Item = \"103\";"
  },
  "api/FastEndpoints.Security.JWTBearer.html": {
    "href": "api/FastEndpoints.Security.JWTBearer.html",
    "title": "Class JWTBearer | FastEndpoints",
    "keywords": "Class JWTBearer static class for easy creation of jwt bearer auth tokens Inheritance System.Object JWTBearer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.Security Assembly : FastEndpoints.Security.dll Syntax public static class JWTBearer Methods CreateToken(String, Nullable<DateTime>, Nullable<IEnumerable<String>>, Nullable<IEnumerable<String>>, Nullable<IEnumerable<Claim>>) generate a jwt token with the supplied parameters Declaration public static string CreateToken(string signingKey, DateTime? expireAt = null, IEnumerable<string>? permissions = null, IEnumerable<string>? roles = null, IEnumerable<Claim>? claims = null) Parameters Type Name Description System.String signingKey the secret key to use for signing the tokens System.Nullable < DateTime > expireAt the expiry date System.Nullable < IEnumerable < System.String >> permissions one or more permissions to assign to the user principal System.Nullable < IEnumerable < System.String >> roles one or more roles to assign the user principal System.Nullable < IEnumerable < System.Security.Claims.Claim >> claims one or more claims to assign to the user principal Returns Type Description System.String CreateToken(String, Nullable<DateTime>, Nullable<IEnumerable<String>>, Nullable<IEnumerable<String>>, (String claimType, String claimValue)[]) generate a jwt token with the supplied parameters Declaration public static string CreateToken(string signingKey, DateTime? expireAt = null, IEnumerable<string>? permissions = null, IEnumerable<string>? roles = null, params (string claimType, string claimValue)[] claims) Parameters Type Name Description System.String signingKey the secret key to use for signing the tokens System.Nullable < DateTime > expireAt the expiry date System.Nullable < IEnumerable < System.String >> permissions one or more permissions to assign to the user principal System.Nullable < IEnumerable < System.String >> roles one or more roles to assign the user principal System.ValueTuple < System.String , System.String >[] claims one or more claims to assign to the user principal Returns Type Description System.String"
  },
  "api/FastEndpoints.Security.Permissions.html": {
    "href": "api/FastEndpoints.Security.Permissions.html",
    "title": "Class Permissions | FastEndpoints",
    "keywords": "Class Permissions inherit from this class and define your applications permissions as public const string public const string Inventory_Create_Item = \"100\"; public const string Inventory_Retrieve_Item = \"101\"; public const string Inventory_Update_Item = \"102\"; public const string Inventory_Delete_Item = \"103\"; Inheritance System.Object Permissions Implements System.Collections.IEnumerable < System.ValueTuple < System.String , System.String >> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.Security Assembly : FastEndpoints.Security.dll Syntax public abstract class Permissions : IEnumerable<(string PermissionName, string PermissionCode)> Constructors Permissions() Declaration protected Permissions() Methods AllCodes() get a list of all permission codes Declaration public IEnumerable<string> AllCodes() Returns Type Description System.Collections.IEnumerable < System.String > AllNames() get a list of all permission names Declaration public IEnumerable<string> AllNames() Returns Type Description System.Collections.IEnumerable < System.String > CodesFor(IEnumerable<String>) get a list of permission codes for a given list of permission names Declaration public IEnumerable<string> CodesFor(IEnumerable<string> names) Parameters Type Name Description System.Collections.IEnumerable < System.String > names the permission names to get the codes for Returns Type Description System.Collections.IEnumerable < System.String > GetEnumerator() Declaration public IEnumerator<(string PermissionName, string PermissionCode)> GetEnumerator() Returns Type Description System.Collections.IEnumerator < System.ValueTuple < System.String , System.String >> NamesFor(IEnumerable<String>) gets a list of permission names for the given list of permission codes Declaration public IEnumerable<string> NamesFor(IEnumerable<string> codes) Parameters Type Name Description System.Collections.IEnumerable < System.String > codes the permission codes to get the permission names for Returns Type Description System.Collections.IEnumerable < System.String > PermissionFromCode(String) get the permission tuple using it's code. returns null if not found Declaration public (string PermissionName, string PermissionCode)? PermissionFromCode(string permissionCode) Parameters Type Name Description System.String permissionCode code of the permission to get Returns Type Description System.Nullable < System.ValueTuple < System.String , System.String >> PermissionFromName(String) get the permission tuple using it's name. returns null if not found Declaration public (string PermissionName, string PermissionCode)? PermissionFromName(string permissionName) Parameters Type Name Description System.String permissionName name of the permission Returns Type Description System.Nullable < System.ValueTuple < System.String , System.String >> Explicit Interface Implementations IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements System.Collections.IEnumerable<>"
  },
  "api/FastEndpoints.Swashbuckle.Extensions.html": {
    "href": "api/FastEndpoints.Swashbuckle.Extensions.html",
    "title": "Class Extensions | FastEndpoints",
    "keywords": "Class Extensions a set of extension methods for adding swagger support Inheritance System.Object Extensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.Swashbuckle Assembly : FastEndpoints.Swashbuckle.dll Syntax public static class Extensions Methods AddSwashbuckle(IServiceCollection, Nullable<Action<SwaggerGenOptions>>, Nullable<Action<JsonOptions>>, Boolean, Int32) enable swagger support for FastEndpoints with a single call. Declaration public static IServiceCollection AddSwashbuckle(this IServiceCollection services, Action<SwaggerGenOptions>? options = null, Action<JsonOptions>? serializerOptions = null, bool addJWTBearerAuth = true, int tagIndex = 1) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services System.Nullable < Action < Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions >> options swaggergen config options System.Nullable < Action < Microsoft.AspNetCore.Mvc.JsonOptions >> serializerOptions json serializer options System.Boolean addJWTBearerAuth set to false to disable auto addition of jwt bearer auth support System.Int32 tagIndex the index of the route path segment to use for tagging/grouping endpoints Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection ConfigureDefaults(SwaggerUIOptions) configure swagger ui with some sensible defaults for FastEndpoints which can be overridden if needed. Declaration public static void ConfigureDefaults(this SwaggerUIOptions o) Parameters Type Name Description Swashbuckle.AspNetCore.SwaggerUI.SwaggerUIOptions o EnableFastEndpoints(SwaggerGenOptions, Int32) enable support for FastEndpoints in swagger Declaration public static void EnableFastEndpoints(this SwaggerGenOptions options, int tagIndex) Parameters Type Name Description Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions options System.Int32 tagIndex the index of the route path segment to use for tagging/grouping endpoints EnableJWTBearerAuth(SwaggerGenOptions) enable jwt bearer authorization support Declaration public static void EnableJWTBearerAuth(this SwaggerGenOptions options) Parameters Type Name Description Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions options SwaggerDoc(SwaggerGenOptions, String, OpenApiInfo, String[]) Declaration public static void SwaggerDoc(this SwaggerGenOptions opts, string documentName, OpenApiInfo info, string[] apiGroupNames) Parameters Type Name Description Swashbuckle.AspNetCore.SwaggerGen.SwaggerGenOptions opts System.String documentName Microsoft.OpenApi.Models.OpenApiInfo info System.String [] apiGroupNames"
  },
  "api/FastEndpoints.Swashbuckle.html": {
    "href": "api/FastEndpoints.Swashbuckle.html",
    "title": "Namespace FastEndpoints.Swashbuckle | FastEndpoints",
    "keywords": "Namespace FastEndpoints.Swashbuckle Classes Extensions a set of extension methods for adding swagger support"
  },
  "api/FastEndpoints.Validation.html": {
    "href": "api/FastEndpoints.Validation.html",
    "title": "Namespace FastEndpoints.Validation | FastEndpoints",
    "keywords": "Namespace FastEndpoints.Validation Classes Validator<TRequest> inherit from this base class to define your dto validators HINT: validators are registered as singletons. i.e. the same validator instance is used to validate each request for best performance. hance, do not maintain state in your validators."
  },
  "api/FastEndpoints.Validation.Validator-1.html": {
    "href": "api/FastEndpoints.Validation.Validator-1.html",
    "title": "Class Validator<TRequest> | FastEndpoints",
    "keywords": "Class Validator<TRequest> inherit from this base class to define your dto validators HINT: validators are registered as singletons. i.e. the same validator instance is used to validate each request for best performance. hance, do not maintain state in your validators. Inheritance System.Object Validator<TRequest> Implements IValidator Namespace : FastEndpoints.Validation Assembly : FastEndpoints.dll Syntax public abstract class Validator<TRequest> : AbstractValidator<TRequest>, IValidatorWithState, IValidator, IServiceResolver where TRequest : class Type Parameters Name Description TRequest the type of the request dto Methods Resolve(Type) resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public object Resolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object Resolve<TService>() resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public TService Resolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve TryResolve(Type) try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public object TryResolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object TryResolve<TService>() try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public TService TryResolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve Implements IValidator"
  },
  "api/FastEndpoints.VersioningOptions.html": {
    "href": "api/FastEndpoints.VersioningOptions.html",
    "title": "Class VersioningOptions | FastEndpoints",
    "keywords": "Class VersioningOptions global endpoint versioning options Inheritance System.Object VersioningOptions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class VersioningOptions Fields Common specifies an endpoint to be common among all api version groups Declaration public const string Common = \"common\" Field Value Type Description System.String Properties DefaultVersion this value will be used on endpoints that does not specify a version Declaration public string DefaultVersion { get; set; } Property Value Type Description System.String Prefix the prefix used in front of the version (for example 'v' produces 'v{version}'). Declaration public string Prefix { get; set; } Property Value Type Description System.String"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome | FastEndpoints",
    "keywords": "A light-weight REST Api framework for ASP.Net 6 that implements REPR (Request-Endpoint-Response) Pattern . FastEndpoints offers a better alternative than the Minimal Api and MVC Controllers with the aim of increasing developer productivity. Performance is on par with the Minimal Api and is faster; uses less memory; and outperforms a MVC Controller by about 46k requests per second in a head-to-head comparison. Features Define your endpoints in multiple class files (even in deeply nested folders) Auto discovery and registration of endpoints Attribute-free endpoint definitions (no attribute argument type restrictions) Secure by default and supports most auth providers Built-in support for JWT Bearer auth scheme Supports policy/permission/role/claim based security Declarative security policy building (inside each endpoint) Supports any IOC container compatible with asp.net Dependencies are automatically property injected Model binding support from route/json body/claims/forms/headers Easy file handling (multipart/form-data) Model validation using FluentValidation rules Convenient business logic validation and error responses Easy access to environment and configuration settings Supports response caching Supports in-process pub/sub event notifications Auto discovery of event notification handlers Convenient integration testing (route-less and strongly-typed) Plays well with the asp.net middleware pipeline Built-in uncaught exception handler Supports swagger/serilog/etc. Visual studio extension (vsix) for easy vertical slice feature scaffolding Plus anything else the Minimal APIs can do... Tutorial Documentation Benchmarks"
  },
  "wiki/Api-Versioning.html": {
    "href": "wiki/Api-Versioning.html",
    "title": "enable endpoint versioning | FastEndpoints",
    "keywords": "enable endpoint versioning specify a Prefix and DefaultVersion for versioning like below. prefix is a string that will be prepended to the version number of an endpoint. default version is used automatically for endpoints that do not specify a version. app.UseFastEndpoints(c => { c.VersioningOptions = o => { o.Prefix = \"v\"; o.DefaultVersion = \"1\"; }; }); once you enable versioning as above, all of your endpoints will be registered with the default version number automatically prepended to them like so: /v1/sales/order /v1/sales/order/cancel /v1/sales/invoice you can specify the version of a particular endpoint with the Version() method: public override void Configure() { Get(\"sales/order\"); Version(\"2\"); } now your endpoints will look like this: /v2/sales/order /v1/sales/order/cancel /v1/sales/invoice disable auto versioning if you do not want endpoints that do not specify a version to be automatically versioned with the DefaultVersion , simply set the default version to VersioningOptions.Common like so: c.VersioningOptions = o => { o.Prefix = \"v\"; o.DefaultVersion = VersioningOptions.Common; }; doing so will enable endpoints to remain un-versioned or common to all api version groups which comes in handy with versioning in swagger as well as not break any existing clients if you've been developing your project without versioning and decide to enable it. versioning in swagger NSwag Swashbuckle you can create multiple swagger documents with separate version groups like below: builder.Services .AddNSwag(s => { s.DocumentName = \"v1\"; s.Title = \"my api\"; s.Version = \"v1.0\"; s.ApiGroupNames = new[] { \"v1\" }; }) .AddNSwag(settings: s => { s.DocumentName = \"v2\"; s.Title = \"my api\"; s.Version = \"v2.0\"; s.ApiGroupNames = new[] { \"v2\" }; }); the above will create two swagger docs/definitions each containing only the endpoints that match the respective api version group. see here for a working example. the important bit here is the ApiGroupNames property which takes care of filtering the right set of endpoints for that particular swagger definition. if that property is not set, all endpoints from all version groups will be shown. if the goal is to get swagger to contain all endpoints of a particular version + all common/un-versioned endpoints, simply do the following: s.ApiGroupNames = new[] { \"v2\", VersioningOptions.Common }; you can create multiple swagger documents with separate version groups like below: builder.Services.AddSwashbuckle(o => { o.SwaggerDoc( documentName: \"v1\", info: new() { Title = \"my api\", Version = \"1.0\" }, apiGroupNames: new[] { \"v1\" }); o.SwaggerDoc( documentName: \"v2\", info: new() { Title = \"my api\", Version = \"2.0\" }, apiGroupNames: new[] { \"v2\" }); }); app.UseSwaggerUI(o => { o.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"v1\"); o.SwaggerEndpoint(\"/swagger/v2/swagger.json\", \"v2\"); }); the above will create two swagger docs/definitions each containing only the endpoints that match the respective api version group. the important bit here is the apiGroupNames parameter which takes care of filtering the right set of endpoints for that particular swagger definition. if that argument is not correctly set, all endpoints from all version groups will be shown. if the goal is to get swagger to contain all endpoints of a particular version + all common/un-versioned endpoints, simply do the following: s.ApiGroupNames = new[] { \"v2\", VersioningOptions.Common };"
  },
  "wiki/Benchmarks.html": {
    "href": "wiki/Benchmarks.html",
    "title": "Head-To-Head Benchmark | FastEndpoints",
    "keywords": "Head-To-Head Benchmark Method Mean Error StdDev Ratio RatioSD Gen 0 Gen 1 Allocated AspNet Minimal Api 84.06 μs 3.721 μs 2.214 μs 1.00 0.00 2.6000 - 21 KB FastEndpoints 84.93 μs 2.539 μs 1.328 μs 1.01 0.04 2.5000 - 21 KB AspNet MVC Controller 112.75 μs 5.053 μs 3.007 μs 1.34 0.06 3.4000 0.1000 28 KB Carter Module 602.90 μs 7.663 μs 5.069 μs 7.17 0.22 5.9000 2.9000 49 KB Bombardier Load Test FastEndpoints (46,341 more requests per second than mvc controller) Statistics Avg Stdev Max Reqs/sec 141291.31 16967.65 230746.18 Latency 3.50ms 479.73us 95.00ms HTTP codes: 1xx - 0, 2xx - 1428565, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 71.64MB/s AspNet Minimal Api Statistics Avg Stdev Max Reqs/sec 145044.77 17963.08 250949.81 Latency 3.39ms 284.73us 62.00ms HTTP codes: 1xx - 0, 2xx - 1471745, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 73.78MB/s AspNet MVC Controller Statistics Avg Stdev Max Reqs/sec 94950.85 11212.91 118144.21 Latency 5.22ms 2.46ms 489.99ms HTTP codes: 1xx - 0, 2xx - 957021, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 47.82MB/s Carter Module Statistics Avg Stdev Max Reqs/sec 7655.85 3286.81 25178.10 Latency 65.09ms 11.37ms 453.00ms HTTP codes: 1xx - 0, 2xx - 77050, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 3.85MB/s parameters used: -c 500 -m POST -f \"body.json\" -H \"Content-Type:application/json\" -d 10s hardware used: AMD Ryzen 7 3700X (8c/16t), 16GB RAM, Windows 11 <!-- .\\bomb.exe -c 500 -m POST -f \"body.json\" -H \"Content-Type:application/json\" -d 10s http://localhost:5000/benchmark/ok/123 --> <!-- ``` { \"FirstName\": \"xxc\", \"LastName\": \"yyy\", \"Age\": 23, \"PhoneNumbers\": [ \"1111111111\", \"2222222222\", \"3333333333\", \"4444444444\", \"5555555555\" ] } ``` -->"
  },
  "wiki/Configuration-Settings.html": {
    "href": "wiki/Configuration-Settings.html",
    "title": "customizing functionality | FastEndpoints",
    "keywords": "customizing functionality there are several areas you can customize/override the default functionality of the library. all configuration settings must be specified during app startup with the UseFastEndpoints() call. specify json serializer options the settings for the default json serializer which is System.Text.Json can be set like so: app.UseFastEndpoints(c => { c.SerializerOptions = o => { o.PropertyNamingPolicy = JsonNamingPolicy.CamelCase; // set null for pascal case }; }); global route prefix you can have a specified string automatically prepended to all route names in your app instead of repeating it in each and every route config method by specifying the prefix at app startup. app.UseFastEndpoints(c => { c.RoutingOptions = o => o.Prefix = \"api\"; }); for example, the following route config methods would result in the below endpoint routes: Get(\"client/update\"); // \"/api/client/update\" Put(\"inventory/delete\"); // \"/api/inventory/delete\" Post(\"sales/recent-list\"); // \"/api/sales/recent-list\" filtering endpoint auto registration if you'd like to prevent some of the endpoints in your project to be not auto registered during startup, you have the option to supply a filtering function which will be run against each discovered endpoint. if your function returns true , that particular endpoint will be registered. if the function returns false that endpoint will be ignored and not registered. app.UseFastEndpoints(c => { c.EndpointRegistrationFilter = ep => { if (ep.Verbs.Contains(\"GET\") && ep.Routes.Contains(\"/api/mobile/test\")) return false; // don't register this endpoint return true; }; }); it is also possible to set a Tag for an endpoint and use that tag to filter out endpoints according to tags during registration as shown below: public override void Configure() { Get(\"client/update\"); Tags(\"Deprecated\", \"ToBeDeleted\"); } app.UseFastEndpoints(c => { c.EndpointRegistrationFilter = ep => { if (ep.Tags?.Contains(\"Deprecated\") is true) return false; // don't register this endpoint return true; }; }); customizing error responses if the default error response is not to your liking, you can specify a function to produce the exact error response you need. whatever object you return from that function will be serialized to json and sent to the client whenever there needs to be an error response sent downstream. the function will be supplied a collection of validation failures you can use to construct your own error response object like so: app.UseFastEndpoints(c => { c.ErrorResponseBuilder = failures => { var list = new List<KeyValuePair<string, string>>(); foreach (var err in failures) list.Add(new(err.PropertyName, err.ErrorMessage)); return list; }; }); customizing de-serialization of json if you'd like to take control of how request bodies are deserialized, simply provide a function like the following. the function is supplied with the incoming http request object, the type of the dto to be created and a cancellation token. deserialize the object how ever you want and return it from the function. do note that this function will be used to deserialize all incoming requests with a json body. it is currently not possible to specify a deserialization function per endpoint. config.RequestDeserializer = async (req, tDto, ct) => { using var reader = new StreamReader(req.Body); return Newtonsoft.Json.JsonConvert.DeserializeObject(await reader.ReadToEndAsync(), tDto); }; customizing serialization of response dtos the response serialization process can be overridden by specifying a function that returns a Task object. you should set the content-type on the http response object and write directly to the response body stream. do note that this function will be used to serialize all outgoing responses where a json body is required. it is currently not possible to specify a serialization function per endpoint. the parameters supplied to the function are as follows: HttpResponse: the http response object object: the response dto to be serialized string: the response content-type CancellationToken: a cancellation token config.ResponseSerializer = (rsp, dto, cType, ct) => { rsp.ContentType = cType; return rsp.WriteAsync(Newtonsoft.Json.JsonConvert.SerializeObject(dto), ct); };"
  },
  "wiki/Dependency-Injection.html": {
    "href": "wiki/Dependency-Injection.html",
    "title": "dependency injection | FastEndpoints",
    "keywords": "dependency injection there are two ways to get access to services registered in the ioc container. consider the following service registration. the service public interface IHelloWorldService { string SayHello(); } public class HelloWorldService : IHelloWorldService { public string SayHello() => \"hello world!\"; } ioc registration builder.Services.AddScoped<IHelloWorldService, HelloWorldService>(); automatic injection services can be automatically property injected by simply adding properties to the endpoint like so: public class MyEndpoint : EndpointWithoutRequest { public IHelloWorldService HelloService { get; set; } public override void Configure() { Verbs(Http.GET); Routes(\"/api/hello-world\"); } public override async Task HandleAsync(EmptyRequest req, CancellationToken ct) { await SendAsync(HelloService.SayHello()); } } manual resolving services can be resolved manually like so: public override async Task HandleAsync(EmptyRequest req, CancellationToken ct) { IHelloWorldService? helloSvc = TryResolve<IHelloWorldService>(); if (helloSvc is null) ThrowError(\"service not resolved!\"); var logger = Resolve<ILogger<MyEndpoint>>(); logger.LogInformation(\"hello service is resolved...\"); await SendAsync(helloSvc.SayHello()); } TryResolve() - this method will try to resolve the given service. returns null if not resolved. Resolve() - this method will throw an exception if the requested service cannot be resolved. pre-resolved services the following services are pre-resolved and available for every endpoint handler with the following properties: property: Config service : IConfiguration property: Env service : IWebHostEnvironment property: Logger service : ILogger they can be used in the endpoint handlers like so: public override async Task HandleAsync(EmptyRequest req, CancellationToken ct) { Logger.LogInformation(\"this is a log message\"); var isProduction = Env.IsProduction(); var smtpServer = Config[\"SMTP:HostName\"]; ... }"
  },
  "wiki/Domain-Entity-Mapping.html": {
    "href": "wiki/Domain-Entity-Mapping.html",
    "title": "domain entity mapping | FastEndpoints",
    "keywords": "domain entity mapping for those of us who are not fans of AutoMapper and the like, this library offers a cleaner way to do manual mapping for request dto to domain entity and back from an entity to a response dto. consider the following request, response and entity classes: public class Request { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string BirthDay { get; set; } } public class Response { public int Id { get; set; } public string UserName { get; set; } public string FullName { get; set; } public int Age { get; set; } } public class Person { public int Id { get; set; } public string FullName { get; set; } public DateOnly DateOfBirth { get; set; } } mapping logic in the endpoint class if you prefer to place your mapping logic in the endpoint definition itself, you can simply use the EndpointWithMapping<TRequest,TResponse,TEntity> generic overload to implement your endpoint and override the MapToEntity() and MapFromEntity() methods like so: public class SavePerson : EndpointWithMapping<Request, Response, Person> { public override void Configure() { Put(\"/api/person\"); AllowAnonymous(); } public override Task HandleAsync(Request r, CancellationToken c) { Person entity = MapToEntity(r); Response = MapFromEntity(entity); return SendAsync(Response); } public override Person MapToEntity(Request r) => new() { Id = r.Id, DateOfBirth = DateOnly.Parse(r.BirthDay), FullName = $\"{r.FirstName} {r.LastName}\" }; public override Response MapFromEntity(Person e) => new() { Id = e.Id, FullName = e.FullName, UserName = $\"USR{e.Id:0000000000}\", Age = (DateOnly.FromDateTime(DateTime.UtcNow).DayNumber - e.DateOfBirth.DayNumber) / 365, }; } mapping logic in a separate class if your preference is to keep the mapping logic in a class of it's own, you can create a separate mapper inheriting from Mapper<TRequest, TResponse, TEntity> like so: public class PersonMapper : Mapper<Request, Response, Person> { public override Person ToEntity(Request r) => new() { Id = r.Id, DateOfBirth = DateOnly.Parse(r.BirthDay), FullName = $\"{r.FirstName} {r.LastName}\" }; public override Response FromEntity(Person e) => new() { Id = e.Id, FullName = e.FullName, UserName = $\"USR{e.Id:0000000000}\", Age = (DateOnly.FromDateTime(DateTime.UtcNow).DayNumber - e.DateOfBirth.DayNumber) / 365, }; } to use the above mapper you need to inherit your endpoint from Endpoint<TRequest, TResponse, TMapper> generic overload like so: public class SavePerson : Endpoint<Request, Response, PersonMapper> { public override void Configure() { Put(\"/api/person\"); AllowAnonymous(); } public override Task HandleAsync(Request r, CancellationToken c) { Person entity = Map.ToEntity(r); Response = Map.FromEntity(entity); return SendAsync(Response); } } the mapping logic can be accessed from the Map property of the endpoint class. that's all there's to it. Note mapper classes are used as singletons for performance reasons. you should not maintain state in your mappers."
  },
  "wiki/Event-Notifications.html": {
    "href": "wiki/Event-Notifications.html",
    "title": "in-process pub/sub notifications | FastEndpoints",
    "keywords": "in-process pub/sub notifications if you'd like to take an event driven approach to building your application, you have the option to publish events from your endpoint handlers and have completely decoupled event-handlers to take action when events are published. it's a simple 3 step process to do event driven work. 1. define an event model/ dto this is the data contract that will be communicated across processes. public class OrderCreatedEvent { public string OrderID { get; set; } public string CustomerName { get; set; } public decimal OrderTotal { get; set; } } 2. define an event handler this is the code that will be fired/executed when events of the above dto type gets published. public class OrderCreationHandler : FastEventHandler<OrderCreatedEvent> { public override Task HandleAsync(OrderCreatedEvent eventModel, CancellationToken ct) { var logger = Resolve<ILogger<OrderCreationHandler>>(); logger.LogInformation($\"order created event received:[{eventModel.OrderID}]\"); return Task.CompletedTask; } } 3. publish the event simply hand in an event model/dto to the PublishAsync() method. public class CreateOrderEndpoint : Endpoint<CreateOrderRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/sales/orders/create\"); } public override async Task HandleAsync(CreateOrderRequest req, CancellationToken ct) { var orderID = await orderRepo.CreateNewOrder(req); await PublishAsync(new OrderCreatedEvent { OrderID = orderID, CustomerName = req.Customer, OrderTotal = req.OrderValue }); await SendOkAsync(); } } the PublishAsync() method the PublishAsync() method has an overload that will take a Mode enum that lets you specify whether to wait for all subscribers to finish; wait for any subscriber to finish; or wait for none of the subscribers to finish. for example, you can publish an event in a fire-n-forget manner with the following: await PublishAsync(eventModel, Mode.WaitForNone); the default mode is Mode.WaitForAll which will await all subscribers. i.e. execution will only continue after each and every subscriber of the event has completed their work. publishing from event handlers it is also possible to publish events from within event handlers themselves like so: public class OrderCreationHandler : FastEventHandler<OrderCreatedEvent> { public override async Task HandleAsync(OrderCreatedEvent eventModel, CancellationToken ct) { await PublishAsync(new ReOrderLevelReachedEvent { ItemId = \"ITM-0001\", CurrentLevel = 5, }); } }"
  },
  "wiki/Exception-Handler.html": {
    "href": "wiki/Exception-Handler.html",
    "title": "unhandled exception handler | FastEndpoints",
    "keywords": "unhandled exception handler the library ships with a default exception handler middleware you can use to log the exception details on the server and return a user-friendly http 500 response to the requesting client. example json response: { \"Status\": \"Internal Server Error!\", \"Code\": 500, \"Reason\": \"'x' is an invalid start of a value. Path: $.ValMin | LineNumber: 4...\", \"Note\": \"See application log for stack trace.\" } example server log entry: fail: FastEndpoints.ExceptionHandler[0] ================================= HTTP: POST /inventory/adjust-stock TYPE: JsonException REASON: 'x' is an invalid start of a value. Path: $.ValMin | LineNumber: 4... --------------------------------- at System.Text.Json.ThrowHelper.ReThrowWithPath(ReadStack& state,... at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader,... at System.Text.Json.JsonSerializer.ReadCore[TValue](JsonConverter jsonConverter,... ... enabling the exception handler Program.cs enable the middleware as shown below during app startup. var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); var app = builder.Build(); app.UseDefaultExceptionHandler(); //add this app.UseAuthorization(); app.UseFastEndpoints(); app.Run(); appsettings.json disable the aspnetcore diagnostic logging for unhandled exceptions in order to avoid duplicate log entries. { \"Logging\": { \"LogLevel\": { \"Default\": \"Warning\", \"Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware\": \"None\" //add this } }"
  },
  "wiki/File-Handling.html": {
    "href": "wiki/File-Handling.html",
    "title": "handling file uploads | FastEndpoints",
    "keywords": "handling file uploads the following example relays back the image data uploaded to the endpoint in order to demonstrate both receiving and sending of file data: public class MyEndpoint : Endpoint<MyRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/uploads/image\"); AllowFileUploads(); } public override async Task HandleAsync(MyRequest req, CancellationToken ct) { if (Files.Count > 0) { var file = Files[0]; await SendStreamAsync( stream: file.OpenReadStream(), fileName: \"test.png\", fileLengthBytes: file.Length, contentType: \"image/png\"); } await SendNoContentAsync(); } } endpoints by default won't allow multipart/form-data content uploads. you'd have to enable file uploads by using the AllowFileUploads() method in the handler configuration like shown above. the received files are exposed to the endpoint handler via the Files property which is of IFormFileCollection type. binding files to dto file data can also be automatically bound to the request dto by simply adding an IFormFile property with a matching name. public class MyRequest { public int Width { get; set; } public int Height { get; set; } public IFormFile File1 { get; set; } public IFormFile File2 { get; set; } public IFormFile File3 { get; set; } } sending file responses there are 3 methods you can use to send file data down to the client. SendStreamAsync() - you can supply a System.IO.Stream to this method for reading binary data from. SendFileAsync() - you can supply a System.IO.FileInfo instance as the source of the binary data. SendBytesAsync() - you can supply a byte array as the source of data to be sent to the client. all three methods allow you to optionally specify the content-type and file name . if file name is specified, the Content-Disposition: attachment response header will be set with the given file name so that a file download will be initiated by the client/browser. write to response stream instead of using the above methods, you also have the choice of writing directly to the http response stream. see here for an example project that stores and retrieves images in mongodb."
  },
  "wiki/Get-Started.html": {
    "href": "wiki/Get-Started.html",
    "title": "getting started | FastEndpoints",
    "keywords": "getting started follow the steps below to create your first endpoint that will handle an http post request and send a response back to the client. create a new project create an empty web project with the dotnet cli using the following command or using visual studio. dotnet new web -n MyWebApp install nuget package install the latest library version using the following cli command: dotnet add package FastEndpoints or with nuget package manager: Install-Package FastEndpoints prepare startup replace the contents of Program.cs file with the following: global using FastEndpoints; var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); var app = builder.Build(); app.UseAuthorization(); app.UseFastEndpoints(); app.Run(); add a request dto create a file called MyRequest.cs and add the following: public class MyRequest { public string FirstName { get; set; } public string LastName { get; set; } public int Age { get; set; } } add a response dto create a file called MyResponse.cs and add the following: public class MyResponse { public string FullName { get; set; } public bool IsOver18 { get; set; } } add an endpoint definition create a file called MyEndpoint.cs and add the following: public class MyEndpoint : Endpoint<MyRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/user/create\"); AllowAnonymous(); } public override async Task HandleAsync(MyRequest req, CancellationToken ct) { var response = new MyResponse() { FullName = req.FirstName + \" \" + req.LastName, IsOver18 = req.Age > 18 }; await SendAsync(response); } } now run your web app and send a POST request to the /api/user/create endpoint using a REST client such as postman with the following request body: { \"FirstName\": \"marlon\", \"LastName\": \"brando\", \"Age\": 40 } you should then get a response back such as this: { \"FullName\": \"marlon brando\", \"IsOver18\": true } that's all there's to it. you simply configure how the endpoint should be listening to incoming requests from clients in the Configure() section calling methods such as Verbs() , Routes() , AllowAnonymous() , etc. then you override the HandleAsync() method in order to specify your handling logic. the request dto is automatically populated from the json body of your http request and passed in to the handler. when you're done processing, you call the SendAsync() method with a new response dto to be sent to the requesting client. endpoint types there are 4 different endpoint base types you can inherit from. Endpoint<TRequest> - use this type if there's only a request dto. you can however send any object to the client that can be serialized as a response with this generic overload. Endpoint<TRequest,TResponse> - use this type if you have both request and response dtos. the benefit of this generic overload is that you get strongly-typed access to properties of the dto when doing integration testing and validations. EndpointWithoutRequest - use this type if there's no request nor response dto. you can send any serializable object as a response here also. EndpointWithoutRequest<TResponse> - use this type if there's no request dto but there is a response dto. it is also possible to define endpoints with EmptyRequest and EmptyResponse if needed like so: public class MyEndpoint : Endpoint<EmptyRequest,EmptyResponse> { } sending responses there are multiple response sending methods you can use. it is also possible to simply populate the Response property of the endpoint and get a 200 ok response with the value of the Response property serialized in the body automatically. for ex: response dto: public class MyResponse { public string FullName { get; set; } public int Age { get; set; } } endpoint definition: public class MyEndpoint : EndpointWithoutRequest<MyResponse> { public override void Configure() { Get(\"/api/person\"); AllowAnonymous(); } public override async Task HandleAsync(EmptyRequest _, CancellationToken ct) { var person = await dbContext.GetFirstPersonAsync(); Response.FullName = person.FullName; Response.Age = person.Age; } } assigning a new instance to the Response property also has the same effect: public override Task HandleAsync(EmptyRequest _, CancellationToken ct) { Response = new() { FullName = \"john doe\", Age = 124 }; return Task.CompletedTask; }"
  },
  "wiki/Integration-Testing.html": {
    "href": "wiki/Integration-Testing.html",
    "title": "route-less integration testing | FastEndpoints",
    "keywords": "route-less integration testing the recommended approach to test your endpoints is to perform integration testing using the WebApplicationFactory . this library offers a set of extensions to the HttpClient to make testing more convenient in a strongly-typed and route-less manner. i.e. you don't need to specify the route urls when testing endpoints. follow the simple steps below to start WAF testing your endpoints: Note this document is still a work-in-progress. please check back soon... you can have a look at the test project here in the meantime to get an idea."
  },
  "wiki/Misc-Conveniences.html": {
    "href": "wiki/Misc-Conveniences.html",
    "title": "endpoint options | FastEndpoints",
    "keywords": "endpoint options in addition to the convenient methods you can use in the endpoint configuration to setup your endpoints (mentioned in previous pages), you can use the Options() method to customize aspects of endpoint registration/setup like so: Options(b => b.RequireCors(x => x.AllowAnyOrigin()) .RequireHost(\"domain.com\") .ProducesProblem(404)); shorthand route configuration instead of the Verbs() and Routes() combo, you can use the shorthand versions that combines them with Get(), Post(), Put(), Patch(), Delete() when configuring your endpoints like so: public override void Configure( ) { Get(\"/api/customer/{CustomerID}\"); } the above is equivalent to using both Verbs() and Routes() . do note that you can't configure multiple verbs with the shorthand version. you can however setup multiple route patterns with the shorthand methods. endpoint properties the following properties are available to all endpoint classes. BaseURL (string) the base url of the current request in the form of https://hostname:port/ (includes trailing slash). Config (IConfiguration) gives access to current configuration of the web app Env (IWebHostEnvironment) gives access to the current web hosting environment Files (IFormFileCollection) exposes the uploaded file collection in case of multipart/form-data uploads. Form (IFormCollection) exposes the form data in case of application/x-www-form-urlencoded or multipart/form-data uploads. HttpContext (HttpContext) gives access to the current http context of the request. HttpMethod (Http enum value) the http method of the current request as an enum value. Logger (ILogger) the default logger for the current endpoint type Response (TResponse) exposes a blank response dto for the current endpoint before the endpoint handler is executed. or represents the populated response dto after a response has been sent to the client. User (ClaimsPrincipal) the current claims principal associated with the current request. ValidationFailed (bool) indicates the current validation status ValidationFailures (List<ValidationFailure>) the list of validation failures for the current execution context. send methods the following response sending methods are available for use from within endpoint handlers: SendAsync() sends a given response dto or any object that can be serialized as json down to the requesting client. SendCreatedAtAsync() sends a 201 created response with a Location header containing where the resource can be retrieved from. this method is only supported on single verb/route endpoints. it will not produce a Location header if used in a multi verb or multi route endpoint. SendStringAsync() sends a given string to the client in the response body SendOkAsync() sends a 200 ok response without any body. SendErrorsAsync() sends a 400 error response with the current list of validation errors describing the validation failures. SendNoContentAsync() sends a 204 no content response SendNotFoundAsync() sends a 404 not found response SendUnauthorizedAsync() sends a 401 unauthorized response SendForbiddenAsync() sends a 403 unauthorized response SendBytesAsync() sends a byte array to the client SendFileAsync() sends a file to the client SendStreamAsync() sends the contents of a stream to the client hook methods the following 4 hook methods allow you to do something before and after dto validation as well as handler execution. OnBeforeValidate() override this method if you'd like to do something to the request dto before it gets validated. OnAfterValidate() override this method if you'd like to do something to the request dto after it gets validated. OnBeforeHandle() override this method if you'd like to do something to the request dto before the handler is executed. OnAfterHandle() override this method if you'd like to do something after the handler is executed."
  },
  "wiki/Model-Binding.html": {
    "href": "wiki/Model-Binding.html",
    "title": "request dto binding | FastEndpoints",
    "keywords": "request dto binding the endpoint handlers are supplied with fully populated request dtos. the dto property values are automatically bound from the incoming request, from the following sources in the exact order: json body form data route parameters query parameters user claims (if property has [FromClaim] attribute) http headers (if property has [FromHeader] attribute) consider the following request dto and http request: dto public class GetUserRequest { public string UserID { get; set; } } http request route : /api/user/{UserID} url : /api/user/54321 json : { \"UserID\": \"12345\" } when the handler receives the request dto, the value of UserID will be 54321 because route parameters have higher priority than json body. likewise, if you decorate the UserID property with [FromClaim] attribute like so: public class GetUserRequest { [FromClaim] public string UserID { get; set; } } the value of UserID will be whatever claim value the user has for the claim type UserID in their claims. by default if the user does not have a claim type called UserID , then a validation error will be sent automatically to the client. you can make the claim optional by using the following overload of the attribute: [FromClaim(IsRequired = false)] doing so will allow the endpoint handler to execute even if the current user doesn't have the specified claim and model binding will take the value from the highest priority source of the other binding sources mentioned above (if a matching field/route param is present). an example can be seen here . it is also possible to model bind automatically from http headers like so: public class GetUserRequest { [FromHeader] public string TenantID { get; set; } } FromHeader attribute will also by default send an error response if a http header (with the same name as the property being bound to) is not present in the incoming request. you can make the header optional and turn off the default behavior by doing [FromHeader(IsRequired = false)] just like with the FromClaim attribute. Both attributes have the same overloads and behaves similarly. it is also possible for both attributes to bind to properties when the names don't match like so: [FromHeader(\"tenant-id\")] public string TenantID { get; set; } [FromClaim(\"user-id\")] public string UserID { get; set; } route parameters route parameters can be bound to primitive types on the dto using route templates like you'd typically do. request dto public class MyRequest { public string MyString { get; set; } public bool MyBool { get; set; } public int MyInt { get; set; } public long MyLong { get; set; } public double MyDouble { get; set; } public decimal MyDecimal { get; set; } } endpoint public class MyEndpoint : Endpoint<MyRequest> { public override void Configure() { Verbs(Http.GET); Routes(\"/api/{MyString}/{MyBool}/{MyInt}/{MyLong}/{MyDouble}/{MyDecimal}\"); } } if a GET request is made to the url /api/hello world/true/123/12345678/123.45/123.4567 the request dto would have the following property values: MyString - \"hello world\" MyBool - true MyInt - 123 MyLong - 12345678 MyDouble - 123.45 MyDecimal - 123.4567 query parameters in order to bind from query string params, simply use a url that has the same param names as your request dto such as: /api/hello-world/?Message=hello+from+query+string if your request dto has a property called Message it would then have hello from query string as it's value. complex model binding complex model binding is only supported from the json body. for example, the following request dto will be automatically populated from the below json request body. request dto public class UpdateAddressRequest { public int UserID { get; set; } public Address UserAddress { get; set; } public class Address { public string Street { get; set; } public string City { get; set; } public string Country { get; set; } } } json request { \"UserID\": 111, \"Address\": { \"Street\": \"123 road\", \"City\": \"new york\", \"Country\": \"usa\" } } json serialization casing by default the serializer uses camel casing for serializing/deserializing. you can change the casing as shown in the configuration settings section."
  },
  "wiki/Pre-Post-Processors.html": {
    "href": "wiki/Pre-Post-Processors.html",
    "title": "pre/post processors | FastEndpoints",
    "keywords": "pre/post processors rather than writing a common piece of logic repeatedly that must be executed either before or after each request to your system, you can write it as a processor and attach it to endpoints that need them. there are two types of processors. pre-processors and post-processors . pre-processors let's say for example that you'd like to log every request before being executed by your endpoint handlers. you can simply write a pre-processor like below by implementing the interface IPreProcessor<TRequest> : public class MyRequestLogger<TRequest> : IPreProcessor<TRequest> { public Task PreProcessAsync(TRequest req, HttpContext ctx, List<ValidationFailure> failures, CancellationToken ct) { var logger = ctx.RequestServices.GetRequiredService<ILogger<TRequest>>(); logger.LogInformation($\"request:{req?.GetType().FullName} path: {ctx.Request.Path}\"); return Task.CompletedTask; } } and then attach it to the endpoints you need like so: public class CreateOrderEndpoint : Endpoint<CreateOrderRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/sales/orders/create\"); PreProcessors(new MyRequestLogger<CreateOrderRequest>()); } } you can even write a request dto specific processor like so: public class SalesRequestLogger : IPreProcessor<CreateSaleRequest> { public Task PreProcessAsync(CreateSaleRequest req, HttpContext ctx, List<ValidationFailure> failures, CancellationToken ct) { var logger = ctx.RequestServices.GetRequiredService<ILogger<CreateSaleRequest>>(); logger.LogInformation($\"sale value:{req.SaleValue}\"); return Task.CompletedTask; } } short-circuiting execution it is possible to end processing the request by returning a response from within a pre-processor like so: public class SecurityProcessor<TRequest> : IPreProcessor<TRequest> { public Task PreProcessAsync(TRequest req, HttpContext ctx, List<ValidationFailure> failures, CancellationToken ct) { var tenantID = ctx.Request.Headers[\"tenant-id\"].FirstOrDefault(); if (tenantID == null) { failures.Add(new(\"MissingHeaders\", \"The [tenant-id] header needs to be set!\")); return ctx.Response.SendErrorsAsync(failures); //sending response here } if (tenantID != \"qwerty\") return ctx.Response.SendForbiddenAsync(); //sending response here return Task.CompletedTask; } } all the Send* methods supported by endpoint handlers are available. the send methods are accessed from the ctx.Response property as shown above. when a response is sent from a pre-processor, the handler method is not executed. however, if there are multiple pre-processors configured, they will be executed. if another pre-processor also wants to send a response, they must check if it's possible to do so by checking the property ctx.Response.HasStarted to see if a previously executed pre-processor has already sent a response to the client. post-processors post-processors are executed after your endpoint handler has completed it's work. they can be created similarly by implementing the interface IPostProcessor<TRequest, TResponse> : public class MyResponseLogger<TRequest, TResponse> : IPostProcessor<TRequest, TResponse> { public Task PostProcessAsync(TRequest req, TResponse res, HttpContext ctx, IReadOnlyCollection<ValidationFailure> failures, CancellationToken ct) { var logger = ctx.RequestServices.GetRequiredService<ILogger<TResponse>>(); if (res is CreateSaleResponse response) { logger.LogWarning($\"sale complete: {response.OrderID}\"); } return Task.CompletedTask; } } and then attach it to endpoints like so: public class CreateOrderEndpoint : Endpoint<CreateSaleRequest, CreateSaleResponse> { public override void Configure() { Verbs(Http.POST); Routes(\"/sales/orders/create\"); PostProcessors(new MyResponseLogger<CreateSaleRequest, CreateSaleResponse>()); } } multiple processors you can attach multiple processors with both PreProcessors() and PostProcessors() methods. the processors are executed in the order they are supplied to the methods."
  },
  "wiki/Response-Caching.html": {
    "href": "wiki/Response-Caching.html",
    "title": "response caching | FastEndpoints",
    "keywords": "response caching in order to get response caching working, you need to enable the response caching middleware and define how responses are cached using the ResponseCache() method in the endpoint configuration. this method supports all arguments of the [ResponseCache] attribute you'd typically use with mvc except for the CacheProfileName argument as cache profiles are not supported. see this document for an intro to response caching in asp.net middleware. startup global using FastEndpoints; var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); builder.Services.AddResponseCaching(); //add this var app = builder.Build(); app.UseAuthorization(); app.UseResponseCaching(); //add this app.UseFastEndpoints(); app.Run(); endpoint public class MyEndpoint : EndpointWithoutRequest { public override void Configure() { Verbs(Http.GET); Routes(\"/api/cached-ticks\"); ResponseCache(60); //cache for 60 seconds } public override Task HandleAsync(EmptyRequest req, CancellationToken ct) { return SendAsync(new { Message = \"this response is cached\" Ticks = DateTime.UtcNow.Ticks }); } }"
  },
  "wiki/Security.html": {
    "href": "wiki/Security.html",
    "title": "securing endpoints | FastEndpoints",
    "keywords": "securing endpoints endpoints are secure by default and you'd have to call AllowAnonymous() in the configuration if you'd like to allow unauthenticated users to access a particular endpoint. jwt bearer authentication support for easy jwt bearer authentication is provided. you simply need to install the FastEndpoints.Security package and register it in the middleware pipeline like so: program.cs global using FastEndpoints; global using FastEndpoints.Security; //add this var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); builder.Services.AddAuthenticationJWTBearer(\"TokenSigningKey\"); //add this var app = builder.Build(); app.UseAuthentication(); //add this app.UseAuthorization(); app.UseFastEndpoints(); app.Run(); generating jwt tokens you can generate a jwt token for sending to the client with an endpoint that signs in users like so: public class UserLoginEndpoint : Endpoint<LoginRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/login\"); AllowAnonymous(); } public override async Task HandleAsync(LoginRequest req, CancellationToken ct) { if (req.Username == \"admin\" && req.Password == \"pass\") { var jwtToken = JWTBearer.CreateToken( signingKey: \"TokenSigningKey\", expireAt: DateTime.UtcNow.AddDays(1), claims: new[] { (\"Username\", req.Username), (\"UserID\", \"001\") }, roles: new[] { \"Admin\", \"Management\" }, permissions: new[] { \"ManageInventory\", \"ManageUsers\" }); await SendAsync(new { Username = req.Username, Token = jwtToken }); } else { ThrowError(\"The supplied credentials are invalid!\"); } } } endpoint authorization once an authentication provider is registered such as jwt bearer as shown above, you can restrict access to users based on the following: policies claims roles permissions pre-built security policies security policies can be pre-built and registered during app startup and endpoints can choose to allow access to users based on the registered policy names like so: startup builder.Services.AddAuthorization(o => o.AddPolicy(\"ManagersOnlyPolicy\", b => b.RequireRole(\"Manager\") .RequireClaim(\"ManagerID\"))); endpoint public class UpdateUserEndpoint : Endpoint<UpdateUserRequest> { public override void Configure() { Verbs(Http.PUT); Routes(\"/api/users/update\"); Policies(\"ManagersOnlyPolicy\"); } } declarative security policies instead of registering each security policy at startup you can selectively specify security requirements for each endpoint in the endpoint configuration itself like so: public class RestrictedEndpoint : Endpoint<RestrictedRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/restricted\"); Claims(\"AdminID\", \"EmployeeID\"); Roles(\"Admin\", \"Manager\"); Permissions(\"UpdateUsersPermission\", \"DeleteUsersPermission\"); } } Claims() method with this method you are specifying that if a user principal has ANY of the specified claims, access should be allowed. if the requirement is to allow access only if ALL specified claims are present, you can use the ClaimsAll() method. Permissions() method just like above, you can specify that ANY of the specified permissions should allow access. Or require ALL of the specified permissions by using the PermissionsAll() method. Roles() method similarly, you are specifying that ANY of the given roles should allow access to a user principal who has it. AllowAnonymous() method use this method if you'd like to allow unauthenticated users to access a particular endpoint. it is also possible to specify which http verbs you'd like to allow anonymous access to like so: public class RestrictedEndpoint : Endpoint<RestrictedRequest> { public override void Configure() { Verbs(Http.POST, Http.PUT, Http.PATCH); Routes(\"/api/restricted\"); AllowAnonymous(Http.POST); } } the above endpoint is listening for all 3 http methods on the same route but only POST method is allowed to be accessed anonymously. it is useful for example when you'd like to use the same handler logic for create/replace/update scenarios and create operation is allowed to be done by anonymous users. using just AllowAnonymous() without any arguments means all verbs are allowed anonymous access. other auth providers all auth providers compatible with the asp.net middleware pipeline can be registered and used like above. the only difference is that you use the methods mentioned above to restrict access to endpoints rather than using the [Authorize] attribute as you would typically do. Tip here's an example project using Auth0 with permissions."
  },
  "wiki/Swagger-Support.html": {
    "href": "wiki/Swagger-Support.html",
    "title": "swagger support | FastEndpoints",
    "keywords": "swagger support you can choose between NSwag or Swashbuckle based swagger support. however, do note that your mileage may vary since those libraries are presently tied closely to the mvc framework and support for .net 6 minimal api is lacking in some areas. if you find some rough edges with the swagger support in FastEndpoints, please get in touch by creating a github issue or submit a pull request if you have experience dealing with swagger. NSwag Swashbuckle enable nswag first install the FastEndpoints.NSwag package and add 4 lines to your app startup: global using FastEndpoints; using FastEndpoints.NSwag; //add this var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); builder.Services.AddNSwag(); //add this var app = builder.Build(); app.UseAuthorization(); app.UseFastEndpoints(); app.UseOpenApi(); //add this app.UseSwaggerUi3(s => s.ConfigureDefaults()); //add this app.Run(); you can then visit /swagger or /swagger/v1/swagger.json to see swagger output. configuration swagger options can be configured as you'd typically do like follows: builder.Services.AddNSwag(settings => { settings.Title = \"My API\"; settings.Version = \"v1\"; }); describe endpoints if the defaults are not satisfactory, you can clear the defaults and describe your endpoints with the Describe() method in configuration like so: public class MyEndpoint : Endpoint<MyRequest, MyResponse> { public override void Configure() { Post(\"/admin/login\"); AllowAnonymous(); Describe(b => b .Accepts<MyRequest>(\"application/json\") .Produces<MyResponse>(200,\"application/json\") .ProducesProblem(500,\"text/plain\")); } } disable auth support for jwt bearer auth is automatically added. if you need to disable it, simply pass a false value to the following parameter: builder.Services.AddNSwag(addJWTBearerAuth: false); json serializer options swagger serialization options can be set with the following parameter: builder.Services.AddNSwag(serializerOptions: o => o.JsonSerializerOptions.PropertyNamingPolicy = null); group endpoints by path segment if you'd like to group your endpoints by a segment of the route url, simply specify an integer indicating which segment to use for tagging/grouping like so: builder.Services.AddNSwag(tagIndex: 2) enable swashbuckle first install the FastEndpoints.Swashbuckle package and add 4 lines to your app startup: global using FastEndpoints; using FastEndpoints.Swagger; //add this var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); builder.Services.AddSwashbuckle(); //add this var app = builder.Build(); app.UseAuthorization(); app.UseFastEndpoints(); app.UseSwagger(); //add this app.UseSwaggerUI(o => o.ConfigureDefaults()); //add this app.Run(); you can then visit /swagger or /swagger/v1/swagger.json to see swagger output. configuration swagger options can be configured as you'd typically do like follows: builder.Services.AddSwashbuckle(options => { options.SwaggerDoc(\"v1\", new OpenApiInfo { Title = \"My API\", Version = \"v1\" }); options.CustomSchemaIds(x => x.Name); }); describe endpoints if the defaults are not satisfactory, you can clear the defaults and describe your endpoints with the Describe() method in configuration like so: public class MyEndpoint : Endpoint<MyRequest, MyResponse> { public override void Configure() { Post(\"/admin/login\"); AllowAnonymous(); Describe(b => b .Accepts<MyRequest>(\"application/json\") .Produces<MyResponse>(200,\"application/json\") .ProducesProblem(500,\"text/plain\")); } } disable auth support for jwt bearer auth is automatically added. if you need to disable it, simply pass a false value to the following parameter: builder.Services.AddSwashbuckle(addJWTBearerAuth: false); json serializer options swagger serialization options can be set with the following parameter: builder.Services.AddSwashbuckle(serializerOptions: o => o.JsonSerializerOptions.PropertyNamingPolicy = null); group endpoints by path segment if you'd like to group your endpoints by a segment of the route url, simply specify an integer indicating which segment to use for tagging/grouping like so: builder.Services.AddSwashbuckle(tagIndex: 2)"
  },
  "wiki/Validation.html": {
    "href": "wiki/Validation.html",
    "title": "request dto validation | FastEndpoints",
    "keywords": "request dto validation request validation is done using FluentValidation rules. fastendpoints uses a customized version of the fluentvalidations library but the api for the end user is the same. please refer to the fluentvalidations website if you haven't used it before. the built-in validation is provided by the FastEndpoints.Validation package. make sure to import it first (or add a global using statement in program.cs) before writing any validators. request dto public class CreateUserRequest { public string FullName { get; set; } public int Age { get; set; } } validator using FastEndpoints.Validation; public class MyValidator : Validator<CreateUserRequest> { public MyValidator() { RuleFor(x => x.FullName) .NotEmpty().WithMessage(\"your name is required!\") .MinimumLength(5).WithMessage(\"your name is too short!\"); RuleFor(x => x.Age) .NotEmpty().WithMessage(\"we need your age!\") .GreaterThan(18).WithMessage(\"you are not legal yet!\"); } } if a request is received that doesn't meet the above model validation criteria, a 400 bad request response will be sent to the client automatically with the following json body describing the error details: { \"StatusCode\": 400, \"Message\": \"One or more errors occured!\", \"Errors\": { \"FullName\": [ \"your name is required!\", \"your name is too short!\" ], \"Age\": [ \"we need your age!\", \"you are not legal yet!\" ] } } disable automatic failure response in cases where you need more control of the validations, you can turn off the default behavior by calling the DontThrowIfValidationFails() method in the endpoint configuration like so: public class CreateUserEndpoint : Endpoint<CreateUserRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/user/create\"); DontThrowIfValidationFails(); } } doing so will not send an automatic error response to the client and your handler will be executed. you can check the validation status in your handler by looking at the ValidationFailures property of the handler like so: public override async Task HandleAsync(CreateUserRequest req, CancellationToken ct) { if (ValidationFailed) { foreach (ValidationFailure failure in ValidationFailures) { var propertyName = failure.PropertyName; var errorMessage = failure.ErrorMessage; } } await SendOkAsync(); } application logic validation in cases where there are app/business logic validation failures during the processing of a request in the handler, you can send an error response to the client like so: public class CreateUserEndpoint : Endpoint<CreateUserRequest, CreateUserResponse> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/user/create\"); } public override async Task HandleAsync(CreateUserRequest req, CancellationToken ct) { bool userExists = await userRepo.UserAlreadyExists(req.EmailAddress); if (userExists) AddError(r => r.EmailAddress, \"this email is already in use!\"); var maxAge = await userRepo.GetMaxAllowedAge(); if (req.Age >= maxAge) AddError(r => r.Age, \"you are not eligible for insurance!\"); ThrowIfAnyErrors(); //because if there are errors, we shouldn't go beyond this point var userID = await userRepo.CreateNew(req); if (userID is null) ThrowError(\"creating a user did not go so well!\"); //error response thrown here await SendAsync(new CreateUserResponse { UserID = userID, FullName = req.FullName }); } } AddError() - this method adds a validation failure to the ValidationFailures property of the handler. ThrowIfAnyErrors() - this method will cause the handler execution to be halted when called and an error response will be sent to the client if there are any validation failures in the ValidationFailures list. if there's none, execution will proceed to the next line. ThrowError() - this method will abort execution immediately and send an error response to the client. Note validators are used as singletons for performance reasons. i.e. there will only ever be one instance of a validator. all requests to an endpoint will use that single instance for validating the incoming request. so, you should not maintain state in your validators."
  },
  "wiki/VS-Extension.html": {
    "href": "wiki/VS-Extension.html",
    "title": "visual studio new item template | FastEndpoints",
    "keywords": "visual studio new item template if you're doing vertical slice architecture and placing each individual feature in their own namespace, you can take advantage of this vs extension that will add a new item to the \"add new file\" dialog of visual studio to make it convenient for you to add feature file sets to your project. once installed, your visual studio add new item dialog will have FastEndpoints Feature File Set listed under Installed > Visual C# node. then, instead of entering a file name, simply enter the namespace you want your new feature to be added to followed by .cs a new feature file set will then be created in the folder you selected. there will be 4 new files created under the namespace you chose. Data.cs - use this class to place all of your data access logic. Models.cs - place your request, response dtos and the validator in this file. Mapper.cs - domain entity mapping logic will live here. Endpoint.cs - this will be your new endpoint definition. click here for an example feature file set."
  }
}